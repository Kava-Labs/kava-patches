From 9b42e18a9526fc84a7c58d41455cdd6a495f848e Mon Sep 17 00:00:00 2001
From: DracoLi <draco@dracoli.com>
Date: Tue, 24 May 2022 12:03:43 -0400
Subject: [PATCH 07/12] Add EIP712 with multiple messages and migrations

Co-authored-by: Nick DeLuca <nickdeluca08@gmail.com>
---
 app/ante/ante_test.go                     |   35 +
 app/ante/eip712.go                        |   13 +-
 app/ante/handler_options.go               |    2 +-
 app/ante/utils_test.go                    |   26 +-
 cmd/ethermintd/main.go                    |    2 +-
 docs/api/proto-docs.md                    |   54 +
 ethereum/eip712/eip712.go                 |  437 +-
 ethereum/eip712/msg_test.go               |  158 +
 ethereum/eip712/types.go                  |   60 +
 go.mod                                    |   12 +-
 go.sum                                    |   51 +-
 proto/ethermint/evm/v1/evm.proto          |   35 +
 x/evm/keeper/grpc_query_test.go           |    1 +
 x/evm/keeper/migrations.go                |   11 +
 x/evm/keeper/params_test.go               |    2 +
 x/evm/keeper/state_transition_test.go     |    1 +
 x/evm/migrations/v2/store.go              |  231 +
 x/evm/migrations/v2/store_test.go         |   45 +
 x/evm/migrations/v2/types/chain_config.go |  165 +
 x/evm/migrations/v2/types/evm.pb.go       | 4664 +++++++++++++++++++++
 x/evm/migrations/v2/types/params.go       |  178 +
 x/evm/module.go                           |   10 +-
 x/evm/types/evm.pb.go                     | 1087 ++++-
 x/evm/types/params.go                     |   68 +-
 x/evm/types/params_test.go                |   21 +-
 25 files changed, 6820 insertions(+), 549 deletions(-)
 create mode 100644 ethereum/eip712/msg_test.go
 create mode 100644 ethereum/eip712/types.go
 create mode 100644 x/evm/migrations/v2/store.go
 create mode 100644 x/evm/migrations/v2/store_test.go
 create mode 100644 x/evm/migrations/v2/types/chain_config.go
 create mode 100644 x/evm/migrations/v2/types/evm.pb.go
 create mode 100644 x/evm/migrations/v2/types/params.go

diff --git a/app/ante/ante_test.go b/app/ante/ante_test.go
index 9762e3db..7f41065f 100644
--- a/app/ante/ante_test.go
+++ b/app/ante/ante_test.go
@@ -26,6 +26,30 @@ func (suite AnteTestSuite) TestAnteHandler() {
 
 	suite.app.EvmKeeper.SetBalance(suite.ctx, addr, big.NewInt(10000000000))
 
+	// allow send & delegate msg via eip712
+	params := suite.app.EvmKeeper.GetParams(suite.ctx)
+	params.EIP712AllowedMsgs = []evmtypes.EIP712AllowedMsg{
+		{
+			MsgTypeUrl:       "/cosmos.bank.v1beta1.MsgSend",
+			MsgValueTypeName: "MsgValueSend",
+			ValueTypes: []evmtypes.EIP712MsgAttrType{
+				{Name: "from_address", Type: "string"},
+				{Name: "to_address", Type: "string"},
+				{Name: "amount", Type: "Coin[]"},
+			},
+		},
+		{
+			MsgTypeUrl:       "/cosmos.staking.v1beta1.MsgDelegate",
+			MsgValueTypeName: "MsgValueDelegate",
+			ValueTypes: []evmtypes.EIP712MsgAttrType{
+				{Name: "delegator_address", Type: "string"},
+				{Name: "validator_address", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+			},
+		},
+	}
+	suite.app.EvmKeeper.SetParams(suite.ctx, params)
+
 	suite.app.FeeMarketKeeper.SetBaseFee(suite.ctx, big.NewInt(100))
 
 	testCases := []struct {
@@ -324,6 +348,17 @@ func (suite AnteTestSuite) TestAnteHandler() {
 				return txBuilder.GetTx()
 			}, false, false, true,
 		},
+		{
+			"success - DeliverTx EIP712 signed Cosmos Tx with multiple messages",
+			func() sdk.Tx {
+				from := acc.GetAddress()
+				coinAmount := sdk.NewCoin(evmtypes.DefaultEVMDenom, sdk.NewInt(20))
+				amount := sdk.NewCoins(coinAmount)
+				gas := uint64(200000)
+				txBuilder := suite.CreateTestEIP712TxBuilderMultipleMsgs(from, privKey, "ethermint_9000-1", gas, amount)
+				return txBuilder.GetTx()
+			}, false, false, true,
+		},
 		{
 			"fails - DeliverTx EIP712 signed Cosmos Tx with wrong Chain ID",
 			func() sdk.Tx {
diff --git a/app/ante/eip712.go b/app/ante/eip712.go
index 9de0d191..eb36ff95 100644
--- a/app/ante/eip712.go
+++ b/app/ante/eip712.go
@@ -37,13 +37,15 @@ func init() {
 type Eip712SigVerificationDecorator struct {
 	ak              evmtypes.AccountKeeper
 	signModeHandler authsigning.SignModeHandler
+	evmKeeper       EVMKeeper
 }
 
 // NewEip712SigVerificationDecorator creates a new Eip712SigVerificationDecorator
-func NewEip712SigVerificationDecorator(ak evmtypes.AccountKeeper, signModeHandler authsigning.SignModeHandler) Eip712SigVerificationDecorator {
+func NewEip712SigVerificationDecorator(ak evmtypes.AccountKeeper, signModeHandler authsigning.SignModeHandler, ek EVMKeeper) Eip712SigVerificationDecorator {
 	return Eip712SigVerificationDecorator{
 		ak:              ak,
 		signModeHandler: signModeHandler,
+		evmKeeper:       ek,
 	}
 }
 
@@ -126,7 +128,8 @@ func (svd Eip712SigVerificationDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx,
 		return next(ctx, tx, simulate)
 	}
 
-	if err := VerifySignature(pubKey, signerData, sig.Data, svd.signModeHandler, authSignTx); err != nil {
+	evmParams := svd.evmKeeper.GetParams(ctx)
+	if err := VerifySignature(pubKey, signerData, sig.Data, svd.signModeHandler, authSignTx, evmParams); err != nil {
 		errMsg := fmt.Errorf("signature verification failed; please verify account number (%d) and chain-id (%s): %w", accNum, chainID, err)
 		return ctx, sdkerrors.Wrap(sdkerrors.ErrUnauthorized, errMsg.Error())
 	}
@@ -142,6 +145,7 @@ func VerifySignature(
 	sigData signing.SignatureData,
 	_ authsigning.SignModeHandler,
 	tx authsigning.Tx,
+	params evmtypes.Params,
 ) error {
 	switch data := sigData.(type) {
 	case *signing.SingleSignatureData:
@@ -162,7 +166,7 @@ func VerifySignature(
 			return sdkerrors.Wrap(sdkerrors.ErrNoSignatures, "tx doesn't contain any msgs to verify signature")
 		}
 
-		txBytes := legacytx.StdSignBytes(
+		txBytes := eip712.ConstructUntypedEIP712Data(
 			signerData.ChainID,
 			signerData.AccountNumber,
 			signerData.Sequence,
@@ -173,7 +177,6 @@ func VerifySignature(
 			},
 			msgs, tx.GetMemo(),
 		)
-
 		signerChainID, err := ethermint.ParseChainID(signerData.ChainID)
 		if err != nil {
 			return sdkerrors.Wrapf(err, "failed to parse chainID: %s", signerData.ChainID)
@@ -215,7 +218,7 @@ func VerifySignature(
 			FeePayer: feePayer,
 		}
 
-		typedData, err := eip712.WrapTxToTypedData(ethermintCodec, extOpt.TypedDataChainID, msgs[0], txBytes, feeDelegation)
+		typedData, err := eip712.WrapTxToTypedData(extOpt.TypedDataChainID, msgs, txBytes, feeDelegation, params)
 		if err != nil {
 			return sdkerrors.Wrap(err, "failed to pack tx data in EIP712 object")
 		}
diff --git a/app/ante/handler_options.go b/app/ante/handler_options.go
index 1eb9baf9..67364ea4 100644
--- a/app/ante/handler_options.go
+++ b/app/ante/handler_options.go
@@ -98,7 +98,7 @@ func newCosmosAnteHandlerEip712(options HandlerOptions) sdk.AnteHandler {
 		ante.NewValidateSigCountDecorator(options.AccountKeeper),
 		ante.NewSigGasConsumeDecorator(options.AccountKeeper, options.SigGasConsumer),
 		// Note: signature verification uses EIP instead of the cosmos signature validator
-		NewEip712SigVerificationDecorator(options.AccountKeeper, options.SignModeHandler),
+		NewEip712SigVerificationDecorator(options.AccountKeeper, options.SignModeHandler, options.EvmKeeper),
 		ante.NewIncrementSequenceDecorator(options.AccountKeeper),
 		ibcante.NewAnteDecorator(options.IBCKeeper),
 	)
diff --git a/app/ante/utils_test.go b/app/ante/utils_test.go
index 8e2b6ef0..a90c57ea 100644
--- a/app/ante/utils_test.go
+++ b/app/ante/utils_test.go
@@ -5,7 +5,6 @@ import (
 	"testing"
 	"time"
 
-	"github.com/cosmos/cosmos-sdk/codec"
 	"github.com/cosmos/cosmos-sdk/x/auth/legacy/legacytx"
 	types2 "github.com/cosmos/cosmos-sdk/x/bank/types"
 	types3 "github.com/cosmos/cosmos-sdk/x/staking/types"
@@ -216,7 +215,7 @@ func (suite *AnteTestSuite) CreateTestEIP712TxBuilderMsgSend(from sdk.AccAddress
 	// Build MsgSend
 	recipient := sdk.AccAddress(common.Address{}.Bytes())
 	msgSend := types2.NewMsgSend(from, recipient, sdk.NewCoins(sdk.NewCoin(evmtypes.DefaultEVMDenom, sdk.NewInt(1))))
-	return suite.CreateTestEIP712CosmosTxBuilder(from, priv, chainId, gas, gasAmount, msgSend)
+	return suite.CreateTestEIP712CosmosTxBuilder(from, priv, chainId, gas, gasAmount, []sdk.Msg{msgSend})
 }
 
 func (suite *AnteTestSuite) CreateTestEIP712TxBuilderMsgDelegate(from sdk.AccAddress, priv cryptotypes.PrivKey, chainId string, gas uint64, gasAmount sdk.Coins) client.TxBuilder {
@@ -224,11 +223,20 @@ func (suite *AnteTestSuite) CreateTestEIP712TxBuilderMsgDelegate(from sdk.AccAdd
 	valEthAddr := tests.GenerateAddress()
 	valAddr := sdk.ValAddress(valEthAddr.Bytes())
 	msgSend := types3.NewMsgDelegate(from, valAddr, sdk.NewCoin(evmtypes.DefaultEVMDenom, sdk.NewInt(20)))
-	return suite.CreateTestEIP712CosmosTxBuilder(from, priv, chainId, gas, gasAmount, msgSend)
+	return suite.CreateTestEIP712CosmosTxBuilder(from, priv, chainId, gas, gasAmount, []sdk.Msg{msgSend})
+}
+
+func (suite *AnteTestSuite) CreateTestEIP712TxBuilderMultipleMsgs(from sdk.AccAddress, priv cryptotypes.PrivKey, chainId string, gas uint64, gasAmount sdk.Coins) client.TxBuilder {
+	valEthAddr := tests.GenerateAddress()
+	valAddr := sdk.ValAddress(valEthAddr.Bytes())
+	recipient := sdk.AccAddress(common.Address{}.Bytes())
+	msgSend := types2.NewMsgSend(from, recipient, sdk.NewCoins(sdk.NewCoin(evmtypes.DefaultEVMDenom, sdk.NewInt(1))))
+	msgDelegate := types3.NewMsgDelegate(from, valAddr, sdk.NewCoin(evmtypes.DefaultEVMDenom, sdk.NewInt(20)))
+	return suite.CreateTestEIP712CosmosTxBuilder(from, priv, chainId, gas, gasAmount, []sdk.Msg{msgSend, msgDelegate, msgDelegate, msgSend})
 }
 
 func (suite *AnteTestSuite) CreateTestEIP712CosmosTxBuilder(
-	from sdk.AccAddress, priv cryptotypes.PrivKey, chainId string, gas uint64, gasAmount sdk.Coins, msg sdk.Msg,
+	from sdk.AccAddress, priv cryptotypes.PrivKey, chainId string, gas uint64, gasAmount sdk.Coins, msgs []sdk.Msg,
 ) client.TxBuilder {
 	var err error
 
@@ -240,14 +248,14 @@ func (suite *AnteTestSuite) CreateTestEIP712CosmosTxBuilder(
 	ethChainId := pc.Uint64()
 
 	// GenerateTypedData TypedData
-	var ethermintCodec codec.ProtoCodecMarshaler
 	fee := legacytx.NewStdFee(gas, gasAmount)
 	accNumber := suite.app.AccountKeeper.GetAccount(suite.ctx, from).GetAccountNumber()
 
-	data := legacytx.StdSignBytes(chainId, accNumber, nonce, 0, fee, []sdk.Msg{msg}, "")
-	typedData, err := eip712.WrapTxToTypedData(ethermintCodec, ethChainId, msg, data, &eip712.FeeDelegationOptions{
+	data := eip712.ConstructUntypedEIP712Data(chainId, accNumber, nonce, 0, fee, msgs, "")
+	evmParams := suite.app.EvmKeeper.GetParams(suite.ctx)
+	typedData, err := eip712.WrapTxToTypedData(ethChainId, msgs, data, &eip712.FeeDelegationOptions{
 		FeePayer: from,
-	})
+	}, evmParams)
 	suite.Require().NoError(err)
 
 	sigHash, err := eip712.ComputeTypedDataHash(typedData)
@@ -288,7 +296,7 @@ func (suite *AnteTestSuite) CreateTestEIP712CosmosTxBuilder(
 	err = builder.SetSignatures(sigsV2)
 	suite.Require().NoError(err)
 
-	err = builder.SetMsgs(msg)
+	err = builder.SetMsgs(msgs...)
 	suite.Require().NoError(err)
 
 	return builder
diff --git a/cmd/ethermintd/main.go b/cmd/ethermintd/main.go
index f67973af..50bebef1 100644
--- a/cmd/ethermintd/main.go
+++ b/cmd/ethermintd/main.go
@@ -17,7 +17,7 @@ func main() {
 
 	rootCmd, _ := NewRootCmd()
 
-	if err := svrcmd.Execute(rootCmd, app.DefaultNodeHome); err != nil {
+	if err := svrcmd.Execute(rootCmd, EnvPrefix, app.DefaultNodeHome); err != nil {
 		switch e := err.(type) {
 		case server.ErrorCode:
 			os.Exit(e.Code)
diff --git a/docs/api/proto-docs.md b/docs/api/proto-docs.md
index 1954f88e..e002e6e0 100644
--- a/docs/api/proto-docs.md
+++ b/docs/api/proto-docs.md
@@ -11,6 +11,9 @@
 - [ethermint/evm/v1/evm.proto](#ethermint/evm/v1/evm.proto)
     - [AccessTuple](#ethermint.evm.v1.AccessTuple)
     - [ChainConfig](#ethermint.evm.v1.ChainConfig)
+    - [EIP712AllowedMsg](#ethermint.evm.v1.EIP712AllowedMsg)
+    - [EIP712MsgAttrType](#ethermint.evm.v1.EIP712MsgAttrType)
+    - [EIP712NestedMsgType](#ethermint.evm.v1.EIP712NestedMsgType)
     - [Log](#ethermint.evm.v1.Log)
     - [Params](#ethermint.evm.v1.Params)
     - [State](#ethermint.evm.v1.State)
@@ -187,6 +190,56 @@ instead of *big.Int.
 
 
 
+<a name="ethermint.evm.v1.EIP712AllowedMsg"></a>
+
+### EIP712AllowedMsg
+EIP712AllowedMsg stores an allowed legacy msg and its eip712 type.
+
+
+| Field | Type | Label | Description |
+| ----- | ---- | ----- | ----------- |
+| `msg_type_url` | [string](#string) |  | msg's proto type name. ie "/cosmos.bank.v1beta1.MsgSend" |
+| `msg_value_type_name` | [string](#string) |  | name of the eip712 value type. ie "MsgValueSend" |
+| `value_types` | [EIP712MsgAttrType](#ethermint.evm.v1.EIP712MsgAttrType) | repeated | types of the msg value |
+| `nested_types` | [EIP712NestedMsgType](#ethermint.evm.v1.EIP712NestedMsgType) | repeated | nested types of the msg value |
+
+
+
+
+
+
+<a name="ethermint.evm.v1.EIP712MsgAttrType"></a>
+
+### EIP712MsgAttrType
+EIP712MsgAttrType is the eip712 type of a single message attribute.
+
+
+| Field | Type | Label | Description |
+| ----- | ---- | ----- | ----------- |
+| `name` | [string](#string) |  |  |
+| `type` | [string](#string) |  |  |
+
+
+
+
+
+
+<a name="ethermint.evm.v1.EIP712NestedMsgType"></a>
+
+### EIP712NestedMsgType
+EIP712MsgType is the eip712 type of a single message.
+
+
+| Field | Type | Label | Description |
+| ----- | ---- | ----- | ----------- |
+| `name` | [string](#string) |  | name of the nested type. ie "Fee", "Coin" |
+| `attrs` | [EIP712MsgAttrType](#ethermint.evm.v1.EIP712MsgAttrType) | repeated | attrs of the nested type |
+
+
+
+
+
+
 <a name="ethermint.evm.v1.Log"></a>
 
 ### Log
@@ -225,6 +278,7 @@ Params defines the EVM module parameters
 | `enable_call` | [bool](#bool) |  | enable call toggles state transitions that use the vm.Call function |
 | `extra_eips` | [int64](#int64) | repeated | extra eips defines the additional EIPs for the vm.Config |
 | `chain_config` | [ChainConfig](#ethermint.evm.v1.ChainConfig) |  | chain config defines the EVM chain configuration parameters |
+| `eip712_allowed_msgs` | [EIP712AllowedMsg](#ethermint.evm.v1.EIP712AllowedMsg) | repeated | list of allowed eip712 msgs and their types |
 
 
 
diff --git a/ethereum/eip712/eip712.go b/ethereum/eip712/eip712.go
index 35a05dc2..2a8ff944 100644
--- a/ethereum/eip712/eip712.go
+++ b/ethereum/eip712/eip712.go
@@ -1,23 +1,49 @@
 package eip712
 
 import (
-	"bytes"
 	"encoding/json"
 	"fmt"
-	"math/big"
-	"reflect"
-	"strings"
 
-	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
 	sdk "github.com/cosmos/cosmos-sdk/types"
 	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
+	"github.com/cosmos/cosmos-sdk/x/auth/legacy/legacytx"
 
-	"github.com/ethereum/go-ethereum/common"
-	"github.com/ethereum/go-ethereum/common/math"
 	"github.com/ethereum/go-ethereum/crypto"
 	"github.com/ethereum/go-ethereum/signer/core/apitypes"
+
+	evmtypes "github.com/tharsis/ethermint/x/evm/types"
 )
 
+// ConstructUntypedEIP712Data returns the bytes to sign for a transaction.
+func ConstructUntypedEIP712Data(chainID string, accnum, sequence, timeout uint64, fee legacytx.StdFee, msgs []sdk.Msg, memo string) []byte {
+	signBytes := legacytx.StdSignBytes(chainID, accnum, sequence, timeout, fee, msgs, memo)
+	var inInterface map[string]interface{}
+	err := json.Unmarshal(signBytes, &inInterface)
+	if err != nil {
+		panic(err)
+	}
+
+	// remove msgs from the sign doc since we will be adding them as separate fields
+	delete(inInterface, "msgs")
+
+	// Add messages as separate fields
+	for i := 0; i < len(msgs); i++ {
+		msg := msgs[i]
+		legacyMsg, ok := msg.(legacytx.LegacyMsg)
+		if !ok {
+			panic(fmt.Errorf("expected %T when using amino JSON", (*legacytx.LegacyMsg)(nil)))
+		}
+		msgsBytes := json.RawMessage(legacyMsg.GetSignBytes())
+		inInterface[fmt.Sprintf("msg%d", i+1)] = msgsBytes
+	}
+
+	bz, err := json.Marshal(inInterface)
+	if err != nil {
+		panic(err)
+	}
+	return sdk.MustSortJSON(bz)
+}
+
 // ComputeTypedDataHash computes keccak hash of typed data for signing.
 func ComputeTypedDataHash(typedData apitypes.TypedData) ([]byte, error) {
 	domainSeparator, err := typedData.HashStruct("EIP712Domain", typedData.Domain.Map())
@@ -39,11 +65,11 @@ func ComputeTypedDataHash(typedData apitypes.TypedData) ([]byte, error) {
 // WrapTxToTypedData is an ultimate method that wraps Amino-encoded Cosmos Tx JSON data
 // into an EIP712-compatible TypedData request.
 func WrapTxToTypedData(
-	cdc codectypes.AnyUnpacker,
 	chainID uint64,
-	msg sdk.Msg,
+	msgs []sdk.Msg,
 	data []byte,
 	feeDelegation *FeeDelegationOptions,
+	params evmtypes.Params,
 ) (apitypes.TypedData, error) {
 	txData := make(map[string]interface{})
 
@@ -51,15 +77,9 @@ func WrapTxToTypedData(
 		return apitypes.TypedData{}, sdkerrors.Wrap(sdkerrors.ErrJSONUnmarshal, "failed to JSON unmarshal data")
 	}
 
-	domain := apitypes.TypedDataDomain{
-		Name:              "Cosmos Web3",
-		Version:           "1.0.0",
-		ChainId:           math.NewHexOrDecimal256(int64(chainID)),
-		VerifyingContract: "cosmos",
-		Salt:              "0",
-	}
+	domain := getTypedDataDomain(chainID)
 
-	msgTypes, err := extractMsgTypes(cdc, "MsgValue", msg)
+	msgTypes, err := extractMsgTypes(msgs, params)
 	if err != nil {
 		return apitypes.TypedData{}, err
 	}
@@ -94,356 +114,71 @@ type FeeDelegationOptions struct {
 	FeePayer sdk.AccAddress
 }
 
-func extractMsgTypes(cdc codectypes.AnyUnpacker, msgTypeName string, msg sdk.Msg) (apitypes.Types, error) {
-	rootTypes := apitypes.Types{
-		"EIP712Domain": {
-			{
-				Name: "name",
-				Type: "string",
-			},
-			{
-				Name: "version",
-				Type: "string",
-			},
-			{
-				Name: "chainId",
-				Type: "uint256",
-			},
-			{
-				Name: "verifyingContract",
-				Type: "string",
-			},
-			{
-				Name: "salt",
-				Type: "string",
-			},
-		},
-		"Tx": {
-			{Name: "account_number", Type: "string"},
-			{Name: "chain_id", Type: "string"},
-			{Name: "fee", Type: "Fee"},
-			{Name: "memo", Type: "string"},
-			{Name: "msgs", Type: "Msg[]"},
-			{Name: "sequence", Type: "string"},
-			// Note timeout_height was removed because it was not getting filled with the legacyTx
-			// {Name: "timeout_height", Type: "string"},
-		},
-		"Fee": {
-			{Name: "amount", Type: "Coin[]"},
-			{Name: "gas", Type: "string"},
-		},
-		"Coin": {
-			{Name: "denom", Type: "string"},
-			{Name: "amount", Type: "string"},
-		},
-		"Msg": {
-			{Name: "type", Type: "string"},
-			{Name: "value", Type: msgTypeName},
-		},
-		msgTypeName: {},
-	}
-
-	if err := walkFields(cdc, rootTypes, msgTypeName, msg); err != nil {
-		return nil, err
-	}
-
-	return rootTypes, nil
-}
-
-const typeDefPrefix = "_"
-
-func walkFields(cdc codectypes.AnyUnpacker, typeMap apitypes.Types, rootType string, in interface{}) (err error) {
-	defer doRecover(&err)
-
-	t := reflect.TypeOf(in)
-	v := reflect.ValueOf(in)
-
-	for {
-		if t.Kind() == reflect.Ptr ||
-			t.Kind() == reflect.Interface {
-			t = t.Elem()
-			v = v.Elem()
-
-			continue
-		}
-
-		break
-	}
-
-	return traverseFields(cdc, typeMap, rootType, typeDefPrefix, t, v)
-}
-
-type cosmosAnyWrapper struct {
-	Type  string      `json:"type"`
-	Value interface{} `json:"value"`
-}
+func extractMsgTypes(msgs []sdk.Msg, params evmtypes.Params) (apitypes.Types, error) {
+	rootTypes := getRootTypes()
 
-func traverseFields(
-	cdc codectypes.AnyUnpacker,
-	typeMap apitypes.Types,
-	rootType string,
-	prefix string,
-	t reflect.Type,
-	v reflect.Value,
-) error {
-	n := t.NumField()
+	// Add types each message
+	for i := 0; i < len(msgs); i++ {
+		msg := msgs[i]
+		msgAttrName := fmt.Sprintf("msg%d", i+1)
+		msgTypeName := fmt.Sprintf("Msg%d", i+1)
 
-	if prefix == typeDefPrefix {
-		if len(typeMap[rootType]) == n {
-			return nil
-		}
-	} else {
-		typeDef := sanitizeTypedef(prefix)
-		if len(typeMap[typeDef]) == n {
-			return nil
+		// ensure eip712 messages implement legacytx.LegacyMsg
+		_, ok := msg.(legacytx.LegacyMsg)
+		if !ok {
+			err := sdkerrors.Wrapf(sdkerrors.ErrInvalidType, "msg %T must implement legacytx.LegacyMsg", (*legacytx.LegacyMsg)(nil))
+			return apitypes.Types{}, err
 		}
-	}
 
-	for i := 0; i < n; i++ {
-		var field reflect.Value
-		if v.IsValid() {
-			field = v.Field(i)
+		// get corresponding allowed msg from params
+		msgType := sdk.MsgTypeURL(msg)
+		allowedMsg := params.EIP712AllowedMsgFromMsgType(msgType)
+		if allowedMsg == nil {
+			err := sdkerrors.Wrapf(
+				sdkerrors.ErrInvalidType,
+				"eip712 message type \"%s\" is not permitted",
+				msgType,
+			)
+			return apitypes.Types{}, err
 		}
 
-		fieldType := t.Field(i).Type
-		fieldName := jsonNameFromTag(t.Field(i).Tag)
-
-		if fieldType == cosmosAnyType {
-			any, ok := field.Interface().(*codectypes.Any)
-			if !ok {
-				return sdkerrors.Wrapf(sdkerrors.ErrPackAny, "%T", field.Interface())
-			}
+		// Add msg property to tx
+		txMsgType := apitypes.Type{Name: msgAttrName, Type: msgTypeName}
+		rootTypes["Tx"] = append(rootTypes["Tx"], txMsgType)
 
-			anyWrapper := &cosmosAnyWrapper{
-				Type: any.TypeUrl,
-			}
-
-			if err := cdc.UnpackAny(any, &anyWrapper.Value); err != nil {
-				return sdkerrors.Wrap(err, "failed to unpack Any in msg struct")
-			}
-
-			fieldType = reflect.TypeOf(anyWrapper)
-			field = reflect.ValueOf(anyWrapper)
-
-			// then continue as normal
-		}
-
-		for {
-			if fieldType.Kind() == reflect.Ptr {
-				fieldType = fieldType.Elem()
-
-				if field.IsValid() {
-					field = field.Elem()
-				}
-
-				continue
-			}
-
-			if fieldType.Kind() == reflect.Interface {
-				fieldType = reflect.TypeOf(field.Interface())
-				continue
-			}
-
-			if field.Kind() == reflect.Ptr {
-				field = field.Elem()
-				continue
-			}
-
-			break
-		}
-
-		var isCollection bool
-		if fieldType.Kind() == reflect.Array || fieldType.Kind() == reflect.Slice {
-			if field.Len() == 0 {
-				// skip empty collections from type mapping
-				continue
-			}
-
-			fieldType = fieldType.Elem()
-			field = field.Index(0)
-			isCollection = true
+		// Add msg type to root types
+		msgValueTypeName := allowedMsg.MsgValueTypeName
+		rootTypes[msgTypeName] = []apitypes.Type{
+			{Name: "type", Type: "string"},
+			{Name: "value", Type: msgValueTypeName},
 		}
 
-		for {
-			if fieldType.Kind() == reflect.Ptr {
-				fieldType = fieldType.Elem()
+		// Add msg value type and nested types
+		if rootTypes[msgValueTypeName] == nil && allowedMsg != nil {
+			// add msg value type
+			rootTypes[msgValueTypeName] = msgAttrsToEIP712Types(allowedMsg.ValueTypes)
 
-				if field.IsValid() {
-					field = field.Elem()
+			// add nested types
+			for _, nestedType := range allowedMsg.NestedTypes {
+				nestedTypeName := nestedType.Name
+				if rootTypes[nestedTypeName] == nil {
+					rootTypes[nestedTypeName] = msgAttrsToEIP712Types(nestedType.Attrs)
 				}
-
-				continue
-			}
-
-			if fieldType.Kind() == reflect.Interface {
-				fieldType = reflect.TypeOf(field.Interface())
-				continue
 			}
-
-			if field.Kind() == reflect.Ptr {
-				field = field.Elem()
-				continue
-			}
-
-			break
-		}
-
-		fieldPrefix := fmt.Sprintf("%s.%s", prefix, fieldName)
-
-		ethTyp := typToEth(fieldType)
-		if len(ethTyp) > 0 {
-			if prefix == typeDefPrefix {
-				typeMap[rootType] = append(typeMap[rootType], apitypes.Type{
-					Name: fieldName,
-					Type: ethTyp,
-				})
-			} else {
-				typeDef := sanitizeTypedef(prefix)
-				typeMap[typeDef] = append(typeMap[typeDef], apitypes.Type{
-					Name: fieldName,
-					Type: ethTyp,
-				})
-			}
-
-			continue
-		}
-
-		if fieldType.Kind() == reflect.Struct {
-
-			var fieldTypedef string
-
-			if isCollection {
-				fieldTypedef = sanitizeTypedef(fieldPrefix) + "[]"
-			} else {
-				fieldTypedef = sanitizeTypedef(fieldPrefix)
-			}
-
-			if prefix == typeDefPrefix {
-				typeMap[rootType] = append(typeMap[rootType], apitypes.Type{
-					Name: fieldName,
-					Type: fieldTypedef,
-				})
-			} else {
-				typeDef := sanitizeTypedef(prefix)
-				typeMap[typeDef] = append(typeMap[typeDef], apitypes.Type{
-					Name: fieldName,
-					Type: fieldTypedef,
-				})
-			}
-
-			if err := traverseFields(cdc, typeMap, rootType, fieldPrefix, fieldType, field); err != nil {
-				return err
-			}
-
-			continue
-		}
-	}
-
-	return nil
-}
-
-func jsonNameFromTag(tag reflect.StructTag) string {
-	jsonTags := tag.Get("json")
-	parts := strings.Split(jsonTags, ",")
-	return parts[0]
-}
-
-// _.foo_bar.baz -> TypeFooBarBaz
-//
-// this is needed for Geth's own signing code which doesn't
-// tolerate complex type names
-func sanitizeTypedef(str string) string {
-	buf := new(bytes.Buffer)
-	parts := strings.Split(str, ".")
-
-	for _, part := range parts {
-		if part == "_" {
-			buf.WriteString("Type")
-			continue
-		}
-
-		subparts := strings.Split(part, "_")
-		for _, subpart := range subparts {
-			buf.WriteString(strings.Title(subpart))
-		}
-	}
-
-	return buf.String()
-}
-
-var (
-	hashType      = reflect.TypeOf(common.Hash{})
-	addressType   = reflect.TypeOf(common.Address{})
-	bigIntType    = reflect.TypeOf(big.Int{})
-	cosmIntType   = reflect.TypeOf(sdk.Int{})
-	cosmosAnyType = reflect.TypeOf(&codectypes.Any{})
-)
-
-// typToEth supports only basic types and arrays of basic types.
-// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md
-func typToEth(typ reflect.Type) string {
-	const str = "string"
-
-	switch typ.Kind() {
-	case reflect.String:
-		return str
-	case reflect.Bool:
-		return "bool"
-	case reflect.Int:
-		return "int64"
-	case reflect.Int8:
-		return "int8"
-	case reflect.Int16:
-		return "int16"
-	case reflect.Int32:
-		return "int32"
-	case reflect.Int64:
-		return "int64"
-	case reflect.Uint:
-		return "uint64"
-	case reflect.Uint8:
-		return "uint8"
-	case reflect.Uint16:
-		return "uint16"
-	case reflect.Uint32:
-		return "uint32"
-	case reflect.Uint64:
-		return "uint64"
-	case reflect.Slice:
-		ethName := typToEth(typ.Elem())
-		if len(ethName) > 0 {
-			return ethName + "[]"
-		}
-	case reflect.Array:
-		ethName := typToEth(typ.Elem())
-		if len(ethName) > 0 {
-			return ethName + "[]"
-		}
-	case reflect.Ptr:
-		if typ.Elem().ConvertibleTo(bigIntType) ||
-			typ.Elem().ConvertibleTo(cosmIntType) {
-			return str
-		}
-	case reflect.Struct:
-		if typ.ConvertibleTo(hashType) ||
-			typ.ConvertibleTo(addressType) ||
-			typ.ConvertibleTo(bigIntType) ||
-			typ.ConvertibleTo(cosmIntType) {
-			return str
 		}
 	}
-
-	return ""
+	return rootTypes, nil
 }
 
-func doRecover(err *error) {
-	if r := recover(); r != nil {
-		if e, ok := r.(error); ok {
-			e = sdkerrors.Wrap(e, "panicked with error")
-			*err = e
-			return
+// msgAttrsToEIP712Types converts a slice of EIP712MsgAttrType to a slice of apitypes.Type.
+func msgAttrsToEIP712Types(attrTypes []evmtypes.EIP712MsgAttrType) []apitypes.Type {
+	msgTypes := make([]apitypes.Type, len(attrTypes))
+	for i, attrType := range attrTypes {
+		apitypes := apitypes.Type{
+			Name: attrType.Name,
+			Type: attrType.Type,
 		}
-
-		*err = fmt.Errorf("%v", r)
+		msgTypes[i] = apitypes
 	}
+	return msgTypes
 }
diff --git a/ethereum/eip712/msg_test.go b/ethereum/eip712/msg_test.go
new file mode 100644
index 00000000..4be734ff
--- /dev/null
+++ b/ethereum/eip712/msg_test.go
@@ -0,0 +1,158 @@
+package eip712
+
+import (
+	"encoding/json"
+	"testing"
+
+	sdk "github.com/cosmos/cosmos-sdk/types"
+	bankTypes "github.com/cosmos/cosmos-sdk/x/bank/types"
+	stakingTypes "github.com/cosmos/cosmos-sdk/x/staking/types"
+	"github.com/ethereum/go-ethereum/signer/core/apitypes"
+	"github.com/stretchr/testify/require"
+	"github.com/tharsis/ethermint/tests"
+
+	evmtypes "github.com/tharsis/ethermint/x/evm/types"
+)
+
+func TestExtractMsgTypes(t *testing.T) {
+	params := evmtypes.DefaultParams()
+	params.EIP712AllowedMsgs = []evmtypes.EIP712AllowedMsg{
+		{
+			MsgTypeUrl:       "/cosmos.bank.v1beta1.MsgSend",
+			MsgValueTypeName: "MsgValueSend",
+			ValueTypes: []evmtypes.EIP712MsgAttrType{
+				{Name: "from_address", Type: "string"},
+				{Name: "to_address", Type: "string"},
+				{Name: "amount", Type: "Coin[]"},
+			},
+		},
+		{
+			MsgTypeUrl:       "/cosmos.staking.v1beta1.MsgDelegate",
+			MsgValueTypeName: "MsgValueDelegate",
+			ValueTypes: []evmtypes.EIP712MsgAttrType{
+				{Name: "delegator_address", Type: "string"},
+				{Name: "validator_address", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+			},
+			NestedTypes: []evmtypes.EIP712NestedMsgType{
+				{
+					Name: "Coin",
+					Attrs: []evmtypes.EIP712MsgAttrType{
+						{Name: "denom", Type: "string"},
+						{Name: "amount", Type: "string"},
+					},
+				},
+				{
+					Name: "Vote",
+					Attrs: []evmtypes.EIP712MsgAttrType{
+						{Name: "voter", Type: "string"},
+					},
+				},
+			},
+		},
+	}
+
+	fromAddr := sdk.AccAddress(tests.GenerateAddress().Bytes())
+	toAddr := sdk.AccAddress(tests.GenerateAddress().Bytes())
+	valAddr := sdk.ValAddress(tests.GenerateAddress().Bytes())
+
+	tests := []struct {
+		name    string
+		msgs    []sdk.Msg
+		exp     string
+		success bool
+		errMsg  string
+	}{
+		{
+			name:    "success",
+			success: true,
+			msgs: []sdk.Msg{
+				bankTypes.NewMsgSend(fromAddr, toAddr, sdk.NewCoins(sdk.NewCoin("atom", sdk.NewInt(1)))),
+				stakingTypes.NewMsgDelegate(fromAddr, valAddr, sdk.NewCoin("atom", sdk.NewInt(1))),
+				bankTypes.NewMsgSend(fromAddr, toAddr, sdk.NewCoins(sdk.NewCoin("atom", sdk.NewInt(2)))),
+			},
+			exp: `{
+				"Coin": [
+					{ "name": "denom", "type": "string" },
+					{ "name": "amount", "type": "string" }
+				],
+				"EIP712Domain": [
+					{ "name": "name", "type": "string" },
+					{ "name": "version", "type": "string" },
+					{ "name": "chainId", "type": "uint256" },
+					{ "name": "verifyingContract", "type": "string" },
+					{ "name": "salt", "type": "string" }
+				],
+				"Fee": [
+					{ "name": "amount", "type": "Coin[]" },
+					{ "name": "gas", "type": "string" }
+				],
+				"Msg1": [
+					{ "name": "type", "type": "string" },
+					{ "name": "value", "type": "MsgValueSend" }
+				],
+				"Msg2": [
+					{ "name": "type", "type": "string" },
+					{ "name": "value", "type": "MsgValueDelegate" }
+				],
+				"Msg3": [
+					{ "name": "type", "type": "string" },
+					{ "name": "value", "type": "MsgValueSend" }
+				],
+				"MsgValueDelegate": [
+					{ "name": "delegator_address", "type": "string" },
+					{ "name": "validator_address", "type": "string" },
+					{ "name": "amount", "type": "Coin" }
+				],
+				"MsgValueSend": [
+					{ "name": "from_address", "type": "string" },
+					{ "name": "to_address", "type": "string" },
+					{ "name": "amount", "type": "Coin[]" }
+				],
+				"Tx": [
+					{ "name": "account_number", "type": "string" },
+					{ "name": "chain_id", "type": "string" },
+					{ "name": "fee", "type": "Fee" },
+					{ "name": "memo", "type": "string" },
+					{ "name": "sequence", "type": "string" },
+					{ "name": "msg1", "type": "Msg1" },
+					{ "name": "msg2", "type": "Msg2" },
+					{ "name": "msg3", "type": "Msg3" }
+				],
+				"Vote": [{ "name": "voter", "type": "string" }]
+			}`,
+		},
+		{
+			name: "fails if msg is not allowed",
+			msgs: []sdk.Msg{
+				bankTypes.NewMsgSend(fromAddr, toAddr, sdk.NewCoins(sdk.NewCoin("atom", sdk.NewInt(1)))),
+				bankTypes.NewMsgMultiSend(
+					[]bankTypes.Input{
+						{Address: fromAddr.String(), Coins: sdk.NewCoins(sdk.NewCoin("atom", sdk.NewInt(1)))},
+					},
+					[]bankTypes.Output{
+						{Address: toAddr.String(), Coins: sdk.NewCoins(sdk.NewCoin("atom", sdk.NewInt(1)))},
+					},
+				),
+			},
+			success: false,
+			errMsg:  "eip712 message type \"/cosmos.bank.v1beta1.MsgMultiSend\" is not permitted: invalid type",
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			msgTypes, err := extractMsgTypes(tt.msgs, params)
+			if tt.success {
+				require.NoError(t, err)
+				var expTypes apitypes.Types
+				err := json.Unmarshal([]byte(tt.exp), &expTypes)
+				require.NoError(t, err)
+				require.Equal(t, expTypes, msgTypes)
+			} else {
+				require.Error(t, err)
+				require.Equal(t, tt.errMsg, err.Error())
+			}
+		})
+	}
+}
diff --git a/ethereum/eip712/types.go b/ethereum/eip712/types.go
new file mode 100644
index 00000000..2cef4539
--- /dev/null
+++ b/ethereum/eip712/types.go
@@ -0,0 +1,60 @@
+package eip712
+
+import (
+	"github.com/ethereum/go-ethereum/common/math"
+	"github.com/ethereum/go-ethereum/signer/core/apitypes"
+)
+
+func getTypedDataDomain(chainID uint64) apitypes.TypedDataDomain {
+	return apitypes.TypedDataDomain{
+		Name:              "Kava Cosmos",
+		Version:           "1.0.0",
+		ChainId:           math.NewHexOrDecimal256(int64(chainID)),
+		VerifyingContract: "kavaCosmos",
+		Salt:              "0",
+	}
+}
+
+func getRootTypes() apitypes.Types {
+	return apitypes.Types{
+		"EIP712Domain": {
+			{
+				Name: "name",
+				Type: "string",
+			},
+			{
+				Name: "version",
+				Type: "string",
+			},
+			{
+				Name: "chainId",
+				Type: "uint256",
+			},
+			{
+				Name: "verifyingContract",
+				Type: "string",
+			},
+			{
+				Name: "salt",
+				Type: "string",
+			},
+		},
+		"Tx": {
+			{Name: "account_number", Type: "string"},
+			{Name: "chain_id", Type: "string"},
+			{Name: "fee", Type: "Fee"},
+			{Name: "memo", Type: "string"},
+			{Name: "sequence", Type: "string"},
+			// Note timeout_height was removed because it was not getting filled with the legacyTx
+			// {Name: "timeout_height", Type: "string"},
+		},
+		"Fee": {
+			{Name: "amount", Type: "Coin[]"},
+			{Name: "gas", Type: "string"},
+		},
+		"Coin": {
+			{Name: "denom", Type: "string"},
+			{Name: "amount", Type: "string"},
+		},
+	}
+}
diff --git a/go.mod b/go.mod
index c6b61dd9..a3d0e307 100644
--- a/go.mod
+++ b/go.mod
@@ -42,13 +42,9 @@ require (
 	github.com/99designs/keyring v1.1.6 // indirect
 	github.com/ChainSafe/go-schnorrkel v0.0.0-20200405005733-88cbf1b4c40d // indirect
 	github.com/DataDog/zstd v1.4.5 // indirect
-	github.com/Masterminds/goutils v1.1.1 // indirect
-	github.com/Masterminds/semver v1.5.0 // indirect
-	github.com/Masterminds/sprig v2.22.0+incompatible // indirect
 	github.com/StackExchange/wmi v0.0.0-20180116203802-5d049714c4a6 // indirect
 	github.com/VictoriaMetrics/fastcache v1.6.0 // indirect
 	github.com/Workiva/go-datastructures v1.0.53 // indirect
-	github.com/aokoli/goutils v1.1.1 // indirect
 	github.com/armon/go-metrics v0.3.10 // indirect
 	github.com/beorn7/perks v1.0.1 // indirect
 	github.com/bgentry/speakeasy v0.1.0 // indirect
@@ -71,7 +67,6 @@ require (
 	github.com/dustin/go-humanize v1.0.0 // indirect
 	github.com/dvsekhvalnov/jose2go v0.0.0-20200901110807-248326c1351b // indirect
 	github.com/edsrzf/mmap-go v1.0.0 // indirect
-	github.com/envoyproxy/protoc-gen-validate v0.6.7 // indirect
 	github.com/felixge/httpsnoop v1.0.1 // indirect
 	github.com/fsnotify/fsnotify v1.5.1 // indirect
 	github.com/gballet/go-libpcsclite v0.0.0-20190607065134-2772fd86a8ff // indirect
@@ -98,9 +93,7 @@ require (
 	github.com/hashicorp/hcl v1.0.0 // indirect
 	github.com/hdevalence/ed25519consensus v0.0.0-20210204194344-59a8610d2b87 // indirect
 	github.com/holiman/bloomfilter/v2 v2.0.3 // indirect
-	github.com/huandu/xstrings v1.3.2 // indirect
 	github.com/huin/goupnp v1.0.2 // indirect
-	github.com/imdario/mergo v0.3.12 // indirect
 	github.com/inconshreveable/mousetrap v1.0.0 // indirect
 	github.com/jackpal/go-nat-pmp v1.0.2 // indirect
 	github.com/jmhodges/levigo v1.0.0 // indirect
@@ -114,10 +107,8 @@ require (
 	github.com/matttproud/golang_protobuf_extensions v1.0.1 // indirect
 	github.com/mimoo/StrobeGo v0.0.0-20181016162300-f8f6d4d2b643 // indirect
 	github.com/minio/highwayhash v1.0.2 // indirect
-	github.com/mitchellh/copystructure v1.2.0 // indirect
 	github.com/mitchellh/mapstructure v1.4.3 // indirect
 	github.com/mtibben/percent v0.2.1 // indirect
-	github.com/mwitkow/go-proto-validators v0.3.2 // indirect
 	github.com/nxadm/tail v1.4.8 // indirect
 	github.com/olekukonko/tablewriter v0.0.5 // indirect
 	github.com/pelletier/go-toml v1.9.4 // indirect
@@ -129,8 +120,6 @@ require (
 	github.com/prometheus/common v0.32.1 // indirect
 	github.com/prometheus/procfs v0.7.3 // indirect
 	github.com/prometheus/tsdb v0.7.1 // indirect
-	github.com/pseudomuto/protoc-gen-doc v1.5.1 // indirect
-	github.com/pseudomuto/protokit v0.2.1 // indirect
 	github.com/rcrowley/go-metrics v0.0.0-20200313005456-10cdbea86bc0 // indirect
 	github.com/rjeczalik/notify v0.9.1 // indirect
 	github.com/rs/zerolog v1.23.0 // indirect
@@ -165,6 +154,7 @@ require (
 
 replace (
 	github.com/99designs/keyring => github.com/cosmos/keyring v1.1.7-0.20210622111912-ef00f8ac3d76
+	github.com/cosmos/cosmos-sdk => github.com/kava-labs/cosmos-sdk v0.45.4-kava.3
 	github.com/gogo/protobuf => github.com/regen-network/protobuf v1.3.3-alpha.regen.1
 	google.golang.org/grpc => google.golang.org/grpc v1.33.2
 )
diff --git a/go.sum b/go.sum
index 50949fcb..97eb0280 100644
--- a/go.sum
+++ b/go.sum
@@ -93,14 +93,6 @@ github.com/DataDog/zstd v1.4.5/go.mod h1:1jcaCB/ufaK+sKp1NBhlGmpz41jOoPQ35bpF36t
 github.com/HdrHistogram/hdrhistogram-go v1.1.0/go.mod h1:yDgFjdqOqDEKOvasDdhWNXYg9BVp4O+o5f6V/ehm6Oo=
 github.com/HdrHistogram/hdrhistogram-go v1.1.2/go.mod h1:yDgFjdqOqDEKOvasDdhWNXYg9BVp4O+o5f6V/ehm6Oo=
 github.com/Knetic/govaluate v3.0.1-0.20171022003610-9aa49832a739+incompatible/go.mod h1:r7JcOSlj0wfOMncg0iLm8Leh48TZaKVeNIfJntJ2wa0=
-github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=
-github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=
-github.com/Masterminds/semver v1.4.2/go.mod h1:MB6lktGJrhw8PrUyiEoblNEGEQ+RzHPF078ddwwvV3Y=
-github.com/Masterminds/semver v1.5.0 h1:H65muMkzWKEuNDnfl9d70GUjFniHKHRbFPGBuZ3QEww=
-github.com/Masterminds/semver v1.5.0/go.mod h1:MB6lktGJrhw8PrUyiEoblNEGEQ+RzHPF078ddwwvV3Y=
-github.com/Masterminds/sprig v2.15.0+incompatible/go.mod h1:y6hNFY5UBTIWBxnzTeuNhlNS5hqE0NB0E6fgfo2Br3o=
-github.com/Masterminds/sprig v2.22.0+incompatible h1:z4yfnGrZ7netVz+0EDJ0Wi+5VZCSYp4Z0m2dk6cEM60=
-github.com/Masterminds/sprig v2.22.0+incompatible/go.mod h1:y6hNFY5UBTIWBxnzTeuNhlNS5hqE0NB0E6fgfo2Br3o=
 github.com/Microsoft/go-winio v0.4.14/go.mod h1:qXqCSQ3Xa7+6tgxaGTIe4Kpcdsi+P8jBhyzoq1bpyYA=
 github.com/Microsoft/go-winio v0.5.0/go.mod h1:JPGBdM1cNvN/6ISo+n8V5iA4v8pBzdOpzfwIujj1a84=
 github.com/Microsoft/go-winio v0.5.1 h1:aPJp2QD7OOrhO5tQXqQoGSJc+DjDtWTGLOmNyAm6FgY=
@@ -138,9 +130,6 @@ github.com/allegro/bigcache v1.2.1 h1:hg1sY1raCwic3Vnsvje6TT7/pnZba83LeFck5NrFKS
 github.com/allegro/bigcache v1.2.1/go.mod h1:Cb/ax3seSYIx7SuZdm2G2xzfwmv3TPSk2ucNfQESPXM=
 github.com/andreyvit/diff v0.0.0-20170406064948-c7f18ee00883/go.mod h1:rCTlJbsFo29Kk6CurOXKm700vrz8f0KW0JNfpkRJY/8=
 github.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=
-github.com/aokoli/goutils v1.0.1/go.mod h1:SijmP0QR8LtwsmDs8Yii5Z/S4trXFGFC2oO5g9DP+DQ=
-github.com/aokoli/goutils v1.1.1 h1:/hA+Ywo3AxoDZY5ZMnkiEkUvkK4BPp927ax110KCqqg=
-github.com/aokoli/goutils v1.1.1/go.mod h1:SijmP0QR8LtwsmDs8Yii5Z/S4trXFGFC2oO5g9DP+DQ=
 github.com/apache/arrow/go/arrow v0.0.0-20191024131854-af6fa24be0db/go.mod h1:VTxUBvSJ3s3eHAg65PNgrsn5BtqCRPdmyXh6rAfdxN0=
 github.com/apache/thrift v0.12.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=
 github.com/apache/thrift v0.13.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=
@@ -180,7 +169,6 @@ github.com/bgentry/speakeasy v0.1.0 h1:ByYyxL9InA1OWqxJqqp2A5pYHUrCiAL6K3J+LKSsQ
 github.com/bgentry/speakeasy v0.1.0/go.mod h1:+zsyZBPWlz7T6j88CTgSN5bM796AkVf0kBD4zp0CCIs=
 github.com/bits-and-blooms/bitset v1.2.0/go.mod h1:gIdJ4wp64HaoK2YrL1Q5/N7Y16edYb8uY+O0FJTyyDA=
 github.com/bketelsen/crypt v0.0.3-0.20200106085610-5cbc8cc4026c/go.mod h1:MKsuJmJgSg28kpZDP6UIiPt0e0Oz0kqKNGyRaWEPv84=
-github.com/bketelsen/crypt v0.0.4/go.mod h1:aI6NrJ0pMGgvZKL1iVgXLnfIFJtfV+bKCoqOes/6LfM=
 github.com/bmizerany/pat v0.0.0-20170815010413-6226ea591a40/go.mod h1:8rLXio+WjiTceGBHIoTvn60HIbs7Hm7bcHjyrSqYB9c=
 github.com/boltdb/bolt v1.3.1/go.mod h1:clJnj/oiGkjum5o1McbSZDSLxVThjynRyGBgiAx27Ps=
 github.com/btcsuite/btcd v0.0.0-20171128150713-2e60448ffcc6/go.mod h1:Dmm/EzmjnCiweXmzRIAiUWCInVmPgjkzgv5k4tVyXiQ=
@@ -262,9 +250,6 @@ github.com/coreos/pkg v0.0.0-20160727233714-3ac0863d7acf/go.mod h1:E3G3o1h8I7cfc
 github.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=
 github.com/cosmos/btcutil v1.0.4 h1:n7C2ngKXo7UC9gNyMNLbzqz7Asuf+7Qv4gnX/rOdQ44=
 github.com/cosmos/btcutil v1.0.4/go.mod h1:Ffqc8Hn6TJUdDgHBwIZLtrLQC1KdJ9jGJl/TvgUaxbU=
-github.com/cosmos/cosmos-sdk v0.45.1/go.mod h1:XXS/asyCqWNWkx2rW6pSuen+EVcpAFxq6khrhnZgHaQ=
-github.com/cosmos/cosmos-sdk v0.45.3 h1:PiVSU3IkNEDPhoxOZHk2lPnhwBBJgEYAtAR0jGXRN4g=
-github.com/cosmos/cosmos-sdk v0.45.3/go.mod h1:qYm5JEr0ZlbnmoP/Q3b+dYMOliHf4ddHirpILiwZzqg=
 github.com/cosmos/go-bip39 v0.0.0-20180819234021-555e2067c45d/go.mod h1:tSxLoYXyBmiFeKpvmq4dzayMdCjCnu8uqmCysIGBT2Y=
 github.com/cosmos/go-bip39 v1.0.0 h1:pcomnQdrdH22njcAatO0yWojsUnCO3y2tNoV1cb6hHY=
 github.com/cosmos/go-bip39 v1.0.0/go.mod h1:RNJv0H/pOIVgxw6KS7QeX2a0Uo0aKUlfhZ4xuwvCdJw=
@@ -342,10 +327,7 @@ github.com/edsrzf/mmap-go v1.0.0/go.mod h1:YO35OhQPt3KJa3ryjFM5Bs14WD66h8eGKpfaB
 github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
 github.com/envoyproxy/go-control-plane v0.10.1/go.mod h1:AY7fTTXNdv/aJ2O5jwpxAPOWUZ7hQAEvzN5Pf27BkQQ=
 github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
-github.com/envoyproxy/protoc-gen-validate v0.3.0-java/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
 github.com/envoyproxy/protoc-gen-validate v0.6.2/go.mod h1:2t7qjJNvHPx8IjnBOzl9E9/baC+qXE/TeeyBRzgJDws=
-github.com/envoyproxy/protoc-gen-validate v0.6.7 h1:qcZcULcd/abmQg6dwigimCNEyi4gg31M/xaciQlDml8=
-github.com/envoyproxy/protoc-gen-validate v0.6.7/go.mod h1:dyJXwwfPK2VSqiB9Klm1J6romD608Ba7Hij42vrOBCo=
 github.com/ethereum/go-ethereum v1.9.25/go.mod h1:vMkFiYLHI4tgPw4k2j4MHKoovchFE8plZ0M9VMk4/oM=
 github.com/ethereum/go-ethereum v1.10.4/go.mod h1:nEE0TP5MtxGzOMd7egIrbPJMQBnhVU3ELNxhBglIzhg=
 github.com/ethereum/go-ethereum v1.10.16 h1:3oPrumn0bCW/idjcxMn5YYVCdK7VzJYIvwGZUGLEaoc=
@@ -464,7 +446,6 @@ github.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71
 github.com/golang/mock v1.5.0/go.mod h1:CWnOUgYIOo4TcNZ0wHX3YZCqsaM1I1Jvs6v3mP3KVu8=
 github.com/golang/mock v1.6.0 h1:ErTB+efbowRARo13NNdxyJji2egdxLGQhRaY+DUumQc=
 github.com/golang/mock v1.6.0/go.mod h1:p6yTPP+5HYm5mzsMV8JkE6ZKdX+/wYM6Hr+LicevLPs=
-github.com/golang/protobuf v1.0.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
 github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
 github.com/golang/protobuf v1.3.0/go.mod h1:Qd/q+1AKNOZr9uGQzbzCmRO6sUih6GTPZv6a1/R87v0=
 github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
@@ -646,9 +627,6 @@ github.com/holiman/uint256 v1.1.1/go.mod h1:y4ga/t+u+Xwd7CpDgZESaRcWy0I7XMlTMA25
 github.com/holiman/uint256 v1.2.0 h1:gpSYcPLWGv4sG43I2mVLiDZCNDh/EpGjSk8tmtxitHM=
 github.com/holiman/uint256 v1.2.0/go.mod h1:y4ga/t+u+Xwd7CpDgZESaRcWy0I7XMlTMA25ApIH5Jw=
 github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
-github.com/huandu/xstrings v1.0.0/go.mod h1:4qWG/gcEcfX4z/mBDHJ++3ReCw9ibxbsNJbcucJdbSo=
-github.com/huandu/xstrings v1.3.2 h1:L18LIDzqlW6xN2rEkpdV8+oL/IXWJ1APd+vsdYy4Wdw=
-github.com/huandu/xstrings v1.3.2/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=
 github.com/hudl/fargo v1.3.0/go.mod h1:y3CKSmjA+wD2gak7sUSXTAoopbhU08POFhmITJgmKTg=
 github.com/hudl/fargo v1.4.0/go.mod h1:9Ai6uvFy5fQNq6VPKtg+Ceq1+eTY4nKUlR2JElEOcDo=
 github.com/huin/goupnp v1.0.0/go.mod h1:n9v9KO1tAxYH82qOn+UTIFQDmx5n1Zxd/ClZDMX7Bnc=
@@ -659,9 +637,6 @@ github.com/huin/goutil v0.0.0-20170803182201-1ca381bf3150/go.mod h1:PpLOETDnJ0o3
 github.com/iancoleman/strcase v0.2.0/go.mod h1:iwCmte+B7n89clKwxIoIXy/HfoL7AsD47ZCWhYzw7ho=
 github.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=
 github.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=
-github.com/imdario/mergo v0.3.4/go.mod h1:2EnlNZ0deacrJVfApfmtdGgDfMuh/nq6Ok1EcJh5FfA=
-github.com/imdario/mergo v0.3.12 h1:b6R2BslTbIEToALKP7LxUvijTsNI9TAe80pLWN2g/HU=
-github.com/imdario/mergo v0.3.12/go.mod h1:jmQim1M+e3UYxmgPu/WyfjB3N3VflVyUjjjwH0dnCYA=
 github.com/improbable-eng/grpc-web v0.14.1/go.mod h1:zEjGHa8DAlkoOXmswrNvhUGEYQA9UI7DhrGeHR1DMGU=
 github.com/improbable-eng/grpc-web v0.15.0 h1:BN+7z6uNXZ1tQGcNAuaU1YjsLTApzkjt2tzCixLaUPQ=
 github.com/improbable-eng/grpc-web v0.15.0/go.mod h1:1sy9HKV4Jt9aEs9JSnkWlRJPuPtwNr0l57L4f878wP8=
@@ -716,6 +691,8 @@ github.com/jung-kurt/gofpdf v1.0.3-0.20190309125859-24315acbbda5/go.mod h1:7Id9E
 github.com/jwilder/encoding v0.0.0-20170811194829-b4e1701a28ef/go.mod h1:Ct9fl0F6iIOGgxJ5npU/IUOhOhqlVrGjyIZc8/MagT0=
 github.com/karalabe/usb v0.0.0-20190919080040-51dc0efba356/go.mod h1:Od972xHfMJowv7NGVDiWVxk2zxnWgjLlJzE+F4F7AGU=
 github.com/karalabe/usb v0.0.2/go.mod h1:Od972xHfMJowv7NGVDiWVxk2zxnWgjLlJzE+F4F7AGU=
+github.com/kava-labs/cosmos-sdk v0.45.4-kava.3 h1:U4esIl4rzu9sApLFYGwbccPQTQdRg6C9exUVrokqSHY=
+github.com/kava-labs/cosmos-sdk v0.45.4-kava.3/go.mod h1:WOqtDxN3eCCmnYLVla10xG7lEXkFjpTaqm2a2WasgCc=
 github.com/keybase/go-keychain v0.0.0-20190712205309-48d3d31d256d h1:Z+RDyXzjKE0i2sTjZ/b1uxiGtPhFy34Ou/Tk0qwN0kM=
 github.com/keybase/go-keychain v0.0.0-20190712205309-48d3d31d256d/go.mod h1:JJNrCn9otv/2QP4D7SMJBgaleKpOf66PnW6F5WGNRIc=
 github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=
@@ -759,7 +736,6 @@ github.com/lightstep/lightstep-tracer-common/golang/gogo v0.0.0-20190605223551-b
 github.com/lightstep/lightstep-tracer-go v0.18.1/go.mod h1:jlF1pusYV4pidLvZ+XD0UBX0ZE6WURAspgAczcDHrL4=
 github.com/lucasjones/reggen v0.0.0-20180717132126-cdb49ff09d77/go.mod h1:5ELEyG+X8f+meRWHuqUOewBOhvHkl7M76pdGEansxW4=
 github.com/lyft/protoc-gen-star v0.5.3/go.mod h1:V0xaHgaf5oCCqmcxYcWiDfTiKsZsRc87/1qhoTACD8w=
-github.com/lyft/protoc-gen-star v0.6.0/go.mod h1:TGAoBVkt8w7MPG72TrKIu85MIdXwDuzJYeZuUPFPNwA=
 github.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
 github.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
 github.com/magiconair/properties v1.8.5/go.mod h1:y3VJvCyxH9uVvJTWEGAELF3aiYNyPKd5NZ3oSwXrF60=
@@ -813,8 +789,6 @@ github.com/minio/highwayhash v1.0.2 h1:Aak5U0nElisjDCfPSG79Tgzkn2gl66NxOMspRrKnA
 github.com/minio/highwayhash v1.0.2/go.mod h1:BQskDq+xkJ12lmlUUi7U0M5Swg3EWR+dLTk+kldvVxY=
 github.com/mitchellh/cli v1.0.0/go.mod h1:hNIlj7HEI86fIcpObd7a0FcrxTWetlwJDGcceTlRvqc=
 github.com/mitchellh/cli v1.1.0/go.mod h1:xcISNoH86gajksDmfB23e/pu+B+GeFRMYmoHXxx3xhI=
-github.com/mitchellh/copystructure v1.2.0 h1:vpKXTN4ewci03Vljg/q9QvCGUDttBOGBIa15WveJJGw=
-github.com/mitchellh/copystructure v1.2.0/go.mod h1:qLl+cE2AmVv+CoeAwDPye/v+N2HKCj9FbZEVFJRxO9s=
 github.com/mitchellh/go-homedir v1.0.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=
 github.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=
 github.com/mitchellh/go-testing-interface v1.0.0/go.mod h1:kRemZodwjscx+RGhAo8eIhFbs2+BFgRtFPeD/KE+zxI=
@@ -829,8 +803,6 @@ github.com/mitchellh/mapstructure v1.4.3 h1:OVowDSCllw/YjdLkam3/sm7wEtOy59d8ndGg
 github.com/mitchellh/mapstructure v1.4.3/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
 github.com/mitchellh/pointerstructure v1.2.0 h1:O+i9nHnXS3l/9Wu7r4NrEdwA2VFTicjUEN1uBnDo34A=
 github.com/mitchellh/pointerstructure v1.2.0/go.mod h1:BRAsLI5zgXmw97Lf6s25bs8ohIXc3tViBH44KcwB2g4=
-github.com/mitchellh/reflectwalk v1.0.2 h1:G2LzWKi524PWgd3mLHV8Y5k7s6XUvT0Gef6zxSIeXaQ=
-github.com/mitchellh/reflectwalk v1.0.2/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=
 github.com/moby/sys/mountinfo v0.4.1/go.mod h1:rEr8tzG/lsIZHBtN/JjGG+LMYx9eXgW2JI+6q0qou+A=
 github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
 github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
@@ -847,9 +819,6 @@ github.com/mtibben/percent v0.2.1/go.mod h1:KG9uO+SZkUp+VkRHsCdYQV3XSZrrSpR3O9ib
 github.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=
 github.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f h1:KUppIJq7/+SVif2QVs3tOP0zanoHgBEVAwHxUSIzRqU=
 github.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=
-github.com/mwitkow/go-proto-validators v0.0.0-20180403085117-0950a7990007/go.mod h1:m2XC9Qq0AlmmVksL6FktJCdTYyLk7V3fKyp0sl1yWQo=
-github.com/mwitkow/go-proto-validators v0.3.2 h1:qRlmpTzm2pstMKKzTdvwPCF5QfBNURSlAgN/R+qbKos=
-github.com/mwitkow/go-proto-validators v0.3.2/go.mod h1:ej0Qp0qMgHN/KtDyUt+Q1/tA7a5VarXUOUxD+oeD30w=
 github.com/mwitkow/grpc-proxy v0.0.0-20181017164139-0f1106ef9c76/go.mod h1:x5OoJHDHqxHS801UIuhqGl6QdSAEJvtausosHSdazIo=
 github.com/naoina/go-stringutil v0.1.0/go.mod h1:XJ2SJL9jCtBh+P9q5btrd/Ylo8XwT/h1USek5+NqSA0=
 github.com/naoina/toml v0.1.2-0.20170918210437-9fafd6967416/go.mod h1:NBIhNtsFMo3G2szEBne+bO4gS192HuIYRqfvOWb4i1E=
@@ -934,7 +903,6 @@ github.com/paulbellamy/ratecounter v0.2.0/go.mod h1:Hfx1hDpSGoqxkVVpBi/IlYD7kChl
 github.com/pborman/uuid v0.0.0-20170112150404-1b00554d8222/go.mod h1:VyrYX9gd7irzKovcSS6BIIEwPRkP2Wm2m9ufcdFSJ34=
 github.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=
 github.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=
-github.com/pelletier/go-toml v1.9.3/go.mod h1:u1nR/EPcESfeI/szUZKdtJ0xRNbUoANCkoOuaOx1Y+c=
 github.com/pelletier/go-toml v1.9.4 h1:tjENF6MfZAg8e4ZmZTeWaWiT2vXtsoO6+iuOjFhECwM=
 github.com/pelletier/go-toml v1.9.4/go.mod h1:u1nR/EPcESfeI/szUZKdtJ0xRNbUoANCkoOuaOx1Y+c=
 github.com/pelletier/go-toml/v2 v2.0.0-beta.8 h1:dy81yyLYJDwMTifq24Oi/IslOslRrDSb3jwDggjz3Z0=
@@ -1009,11 +977,6 @@ github.com/prometheus/procfs v0.7.3/go.mod h1:cz+aTbrPOrUb4q7XlbU9ygM+/jj0fzG6c1
 github.com/prometheus/tsdb v0.6.2-0.20190402121629-4f204dcbc150/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=
 github.com/prometheus/tsdb v0.7.1 h1:YZcsG11NqnK4czYLrWd9mpEuAJIHVQLwdrleYfszMAA=
 github.com/prometheus/tsdb v0.7.1/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=
-github.com/pseudomuto/protoc-gen-doc v1.5.1 h1:Ah259kcrio7Ix1Rhb6u8FCaOkzf9qRBqXnvAufg061w=
-github.com/pseudomuto/protoc-gen-doc v1.5.1/go.mod h1:XpMKYg6zkcpgfpCfQ8GcWBDRtRxOmMR5w7pz4Xo+dYM=
-github.com/pseudomuto/protokit v0.2.0/go.mod h1:2PdH30hxVHsup8KpBTOXTBeMVhJZVio3Q8ViKSAXT0Q=
-github.com/pseudomuto/protokit v0.2.1 h1:kCYpE3thoR6Esm0CUvd5xbrDTOZPvQPTDeyXpZfrJdk=
-github.com/pseudomuto/protokit v0.2.1/go.mod h1:gt7N5Rz2flBzYafvaxyIxMZC0TTF5jDZfRnw25hAAyo=
 github.com/rakyll/statik v0.1.7 h1:OF3QCZUuyPxuGEP7B4ypUa7sB/iHtqOTDYZXGM8KOdQ=
 github.com/rakyll/statik v0.1.7/go.mod h1:AlZONWzMtEnMs7W4e/1LURLiI49pIMmp6V9Unghqrcc=
 github.com/rcrowley/go-metrics v0.0.0-20181016184325-3113b8401b8a/go.mod h1:bCqnVzQkZxMG4s8nGwiZ5l3QUCyqpo9Y+/ZMZ9VjZe4=
@@ -1078,14 +1041,12 @@ github.com/spf13/afero v1.6.0/go.mod h1:Ai8FlHk4v/PARR026UzYexafAt9roJ7LcLMAmO6Z
 github.com/spf13/afero v1.8.2 h1:xehSyVa0YnHWsJ49JFljMpg1HX19V6NDZ1fkm1Xznbo=
 github.com/spf13/afero v1.8.2/go.mod h1:CtAatgMJh6bJEIs48Ay/FOnkljP3WeGUG0MC1RfAqwo=
 github.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
-github.com/spf13/cast v1.3.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
 github.com/spf13/cast v1.4.1 h1:s0hze+J0196ZfEMTs80N7UlFt0BDuQ7Q+JDnHiMWKdA=
 github.com/spf13/cast v1.4.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
 github.com/spf13/cobra v0.0.3/go.mod h1:1l0Ry5zgKvJasoi3XT1TypsSe7PqH0Sj9dhYf7v3XqQ=
 github.com/spf13/cobra v0.0.5/go.mod h1:3K3wKZymM7VvHMDS9+Akkh4K60UwM26emMESw8tLCHU=
 github.com/spf13/cobra v1.0.0/go.mod h1:/6GTrnGXV9HjY+aR4k0oJ5tcvakLuG6EuKReYlHNrgE=
 github.com/spf13/cobra v1.1.1/go.mod h1:WnodtKOvamDL/PwE2M4iKs8aMDBZ5Q5klgD3qfVJQMI=
-github.com/spf13/cobra v1.2.1/go.mod h1:ExllRjgxM/piMAM+3tAZvg8fsklGAf3tPfi+i8t68Nk=
 github.com/spf13/cobra v1.3.0/go.mod h1:BrRVncBjOJa/eUcVVm9CE+oC6as8k+VYr4NY7WCi9V4=
 github.com/spf13/cobra v1.4.0 h1:y+wJpx64xcgO1V+RcnwW0LEHxTKRi2ZDPSBjWnrg88Q=
 github.com/spf13/cobra v1.4.0/go.mod h1:Wo4iy3BUC+X2Fybo0PDqwJIv3dNRiZLHQymsfxlB84g=
@@ -1100,7 +1061,6 @@ github.com/spf13/viper v1.3.2/go.mod h1:ZiWeW+zYFKm7srdB9IoDzzZXaJaI5eL9QjNiN/DM
 github.com/spf13/viper v1.4.0/go.mod h1:PTJ7Z/lr49W6bUbkmS1V3by4uWynFiR9p7+dSq/yZzE=
 github.com/spf13/viper v1.7.0/go.mod h1:8WkrPz2fc9jxqZNCJI/76HCieCp4Q8HaLFoCha5qpdg=
 github.com/spf13/viper v1.7.1/go.mod h1:8WkrPz2fc9jxqZNCJI/76HCieCp4Q8HaLFoCha5qpdg=
-github.com/spf13/viper v1.8.1/go.mod h1:o0Pch8wJ9BVSWGQMbra6iw0oQ5oktSIBaujf1rJH9Ns=
 github.com/spf13/viper v1.10.0/go.mod h1:SoyBPwAtKDzypXNDFKN5kzH7ppppbGZtls1UpIy5AsM=
 github.com/spf13/viper v1.10.1/go.mod h1:IGlFPqhNAPKRxohIzWpI5QEy4kuI7tcl5WvR+8qy1rU=
 github.com/spf13/viper v1.11.0 h1:7OX/1FS6n7jHD1zGrZTM7WtY13ZELRyosK4k93oPr44=
@@ -1120,7 +1080,6 @@ github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+
 github.com/stretchr/objx v0.2.0 h1:Hbg2NidpLE8veEBkEZTL3CvlkUIVzuU9jDplZO54c48=
 github.com/stretchr/objx v0.2.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=
 github.com/stretchr/testify v1.2.0/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
-github.com/stretchr/testify v1.2.1/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
 github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
 github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
 github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
@@ -1394,7 +1353,6 @@ golang.org/x/oauth2 v0.0.0-20201208152858-08078c50e5b5/go.mod h1:KelEdhl1UZF7XfJ
 golang.org/x/oauth2 v0.0.0-20210218202405-ba52d332ba99/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
 golang.org/x/oauth2 v0.0.0-20210220000619-9bb904979d93/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
 golang.org/x/oauth2 v0.0.0-20210313182246-cd4f82c27b84/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
-golang.org/x/oauth2 v0.0.0-20210402161424-2e8d93401602/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
 golang.org/x/oauth2 v0.0.0-20210514164344-f6687ab2804c/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
 golang.org/x/oauth2 v0.0.0-20210628180205-a41e5a781914/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
 golang.org/x/oauth2 v0.0.0-20210805134026-6f1e6394065a/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
@@ -1655,7 +1613,6 @@ google.golang.org/api v0.36.0/go.mod h1:+z5ficQTmoYpPn8LCUNVpK5I7hwkpjbcgqA7I34q
 google.golang.org/api v0.40.0/go.mod h1:fYKFpnQN0DsDSKRVRcQSDQNtqWPfM9i+zNPxepjRCQ8=
 google.golang.org/api v0.41.0/go.mod h1:RkxM5lITDfTzmyKFPt+wGrCJbVfniCr2ool8kTBzRTU=
 google.golang.org/api v0.43.0/go.mod h1:nQsDGjRXMo4lvh5hP0TKqF244gqhGcr/YSIykhUk/94=
-google.golang.org/api v0.44.0/go.mod h1:EBOGZqzyhtvMDoxwS97ctnh0zUmYY6CxqXsc1AvkYD8=
 google.golang.org/api v0.47.0/go.mod h1:Wbvgpq1HddcWVtzsVLyfLp8lDg6AA241LmgIL59tHXo=
 google.golang.org/api v0.48.0/go.mod h1:71Pr1vy+TAZRPkPs/xlCf5SsU8WjuAWv1Pfjbtukyy4=
 google.golang.org/api v0.50.0/go.mod h1:4bNT5pAuq5ji4SRZm+5QIkjny9JAyVD/3gaSihNefaw=
@@ -1664,7 +1621,6 @@ google.golang.org/api v0.54.0/go.mod h1:7C4bFFOvVDGXjfDTAsgGwDgAxRDeQ4X8NvUedIt6
 google.golang.org/api v0.55.0/go.mod h1:38yMfeP1kfjsl8isn0tliTjIb1rJXcQi4UXlbqivdVE=
 google.golang.org/api v0.56.0/go.mod h1:38yMfeP1kfjsl8isn0tliTjIb1rJXcQi4UXlbqivdVE=
 google.golang.org/api v0.57.0/go.mod h1:dVPlbZyBo2/OjBpmvNdpn2GRm6rPy75jyU7bmhdrMgI=
-google.golang.org/api v0.58.0/go.mod h1:cAbP2FsxoGVNwtgNAmmn3y5G1TWAiVYRmg4yku3lv+E=
 google.golang.org/api v0.59.0/go.mod h1:sT2boj7M9YJxZzgeZqXogmhfmRWDtPzT31xkieUbuZU=
 google.golang.org/api v0.61.0/go.mod h1:xQRti5UdCmoCEqFxcz93fTl338AVqDgyaDRuOZ3hg9I=
 google.golang.org/api v0.62.0/go.mod h1:dKmwPCydfsad4qCH08MSdgWjfHOyfpd4VtDGgRFdavw=
@@ -1680,7 +1636,6 @@ google.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww
 google.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
 google.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
 google.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
-google.golang.org/genproto v0.0.0-20180427144745-86e600f69ee4/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
 google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
 google.golang.org/genproto v0.0.0-20180831171423-11092d34479b/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
 google.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
@@ -1764,7 +1719,6 @@ google.golang.org/genproto v0.0.0-20220222213610-43724f9ea8cf/go.mod h1:kGP+zUP2
 google.golang.org/genproto v0.0.0-20220304144024-325a89244dc8/go.mod h1:kGP+zUP2Ddo0ayMi4YuN7C3WZyJvGLZRh8Z5wnAqvEI=
 google.golang.org/genproto v0.0.0-20220310185008-1973136f34c6/go.mod h1:kGP+zUP2Ddo0ayMi4YuN7C3WZyJvGLZRh8Z5wnAqvEI=
 google.golang.org/genproto v0.0.0-20220324131243-acbaeb5b85eb/go.mod h1:hAL49I2IFola2sVEjAn7MEwsja0xp51I0tlGAf9hz4E=
-google.golang.org/genproto v0.0.0-20220407144326-9054f6ed7bac h1:qSNTkEN+L2mvWcLgJOR+8bdHX9rN/IdU3A1Ghpfb1Rg=
 google.golang.org/genproto v0.0.0-20220407144326-9054f6ed7bac/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=
 google.golang.org/genproto v0.0.0-20220414192740-2d67ff6cf2b4 h1:myaecH64R0bIEDjNORIel4iXubqzaHU1K2z8ajBwWcM=
 google.golang.org/genproto v0.0.0-20220414192740-2d67ff6cf2b4/go.mod h1:8w6bsBMX6yCPbAVTeqQHvzxW0EIFigd5lZyahWgyfDo=
@@ -1800,7 +1754,6 @@ gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
 gopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=
 gopkg.in/gcfg.v1 v1.2.3/go.mod h1:yesOnuUOFQAhST5vPY4nbZsb/huCgGGXlipJsBn0b3o=
 gopkg.in/ini.v1 v1.51.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
-gopkg.in/ini.v1 v1.62.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
 gopkg.in/ini.v1 v1.66.2/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
 gopkg.in/ini.v1 v1.66.4 h1:SsAcf+mM7mRZo2nJNGt8mZCjG8ZRaNGMURJw7BsIST4=
 gopkg.in/ini.v1 v1.66.4/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
diff --git a/proto/ethermint/evm/v1/evm.proto b/proto/ethermint/evm/v1/evm.proto
index 406276a2..359006b9 100644
--- a/proto/ethermint/evm/v1/evm.proto
+++ b/proto/ethermint/evm/v1/evm.proto
@@ -24,6 +24,11 @@ message Params {
     (gogoproto.moretags) = "yaml:\"chain_config\"",
     (gogoproto.nullable) = false
   ];
+  // list of allowed eip712 msgs and their types
+  repeated EIP712AllowedMsg eip712_allowed_msgs = 6 [
+    (gogoproto.customname) = "EIP712AllowedMsgs",
+    (gogoproto.nullable) = false
+  ];
 }
 
 // ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
@@ -230,3 +235,33 @@ message TraceConfig {
   // enable return data capture
   bool enable_return_data = 12 [ (gogoproto.jsontag) = "enableReturnData" ];
 }
+
+// EIP712AllowedMsg stores an allowed legacy msg and its eip712 type.
+message EIP712AllowedMsg {
+  // msg's proto type name. ie "/cosmos.bank.v1beta1.MsgSend"
+  string msg_type_url = 1;
+
+  // name of the eip712 value type. ie "MsgValueSend"
+  string msg_value_type_name = 2;
+
+  // types of the msg value
+  repeated EIP712MsgAttrType value_types = 3 [(gogoproto.nullable) = false];
+
+  // nested types of the msg value
+  repeated EIP712NestedMsgType nested_types = 4 [(gogoproto.nullable) = false];
+}
+
+// EIP712MsgType is the eip712 type of a single message.
+message EIP712NestedMsgType {
+  // name of the nested type. ie "Fee", "Coin"
+  string name = 1;
+
+  // attrs of the nested type
+  repeated EIP712MsgAttrType attrs = 2 [(gogoproto.nullable) = false];
+}
+
+// EIP712MsgAttrType is the eip712 type of a single message attribute.
+message EIP712MsgAttrType {
+  string name = 1;
+  string type = 2;
+}
diff --git a/x/evm/keeper/grpc_query_test.go b/x/evm/keeper/grpc_query_test.go
index 82652b7c..e7c5fa6b 100644
--- a/x/evm/keeper/grpc_query_test.go
+++ b/x/evm/keeper/grpc_query_test.go
@@ -401,6 +401,7 @@ func (suite *KeeperTestSuite) TestQueryTxLogs() {
 func (suite *KeeperTestSuite) TestQueryParams() {
 	ctx := sdk.WrapSDKContext(suite.ctx)
 	expParams := types.DefaultParams()
+	expParams.EIP712AllowedMsgs = nil
 
 	res, err := suite.queryClient.Params(ctx, &types.QueryParamsRequest{})
 	suite.Require().NoError(err)
diff --git a/x/evm/keeper/migrations.go b/x/evm/keeper/migrations.go
index 3be1ada6..b5ebe213 100644
--- a/x/evm/keeper/migrations.go
+++ b/x/evm/keeper/migrations.go
@@ -1,5 +1,11 @@
 package keeper
 
+import (
+	sdk "github.com/cosmos/cosmos-sdk/types"
+
+	v2 "github.com/tharsis/ethermint/x/evm/migrations/v2"
+)
+
 // Migrator is a struct for handling in-place store migrations.
 type Migrator struct {
 	keeper Keeper
@@ -11,3 +17,8 @@ func NewMigrator(keeper Keeper) Migrator {
 		keeper: keeper,
 	}
 }
+
+// Migrate1to2 migrates from version 1 to 2.
+func (m Migrator) Migrate1to2(ctx sdk.Context) error {
+	return v2.MigrateStore(ctx, &m.keeper.paramSpace)
+}
diff --git a/x/evm/keeper/params_test.go b/x/evm/keeper/params_test.go
index 9cc6577f..f7b24cd1 100644
--- a/x/evm/keeper/params_test.go
+++ b/x/evm/keeper/params_test.go
@@ -6,9 +6,11 @@ import (
 
 func (suite *KeeperTestSuite) TestParams() {
 	params := suite.app.EvmKeeper.GetParams(suite.ctx)
+	params.EIP712AllowedMsgs = []types.EIP712AllowedMsg{}
 	suite.Require().Equal(types.DefaultParams(), params)
 	params.EvmDenom = "inj"
 	suite.app.EvmKeeper.SetParams(suite.ctx, params)
 	newParams := suite.app.EvmKeeper.GetParams(suite.ctx)
+	newParams.EIP712AllowedMsgs = []types.EIP712AllowedMsg{}
 	suite.Require().Equal(newParams, params)
 }
diff --git a/x/evm/keeper/state_transition_test.go b/x/evm/keeper/state_transition_test.go
index 37314ccb..b389eaa1 100644
--- a/x/evm/keeper/state_transition_test.go
+++ b/x/evm/keeper/state_transition_test.go
@@ -498,6 +498,7 @@ func (suite *KeeperTestSuite) TestResetGasMeterAndConsumeGas() {
 func (suite *KeeperTestSuite) TestEVMConfig() {
 	suite.SetupTest()
 	cfg, err := suite.app.EvmKeeper.EVMConfig(suite.ctx)
+	cfg.Params.EIP712AllowedMsgs = []types.EIP712AllowedMsg{}
 	suite.Require().NoError(err)
 	suite.Require().Equal(types.DefaultParams(), cfg.Params)
 	// london hardfork is enabled by default
diff --git a/x/evm/migrations/v2/store.go b/x/evm/migrations/v2/store.go
new file mode 100644
index 00000000..62bbd322
--- /dev/null
+++ b/x/evm/migrations/v2/store.go
@@ -0,0 +1,231 @@
+package v2
+
+import (
+	sdk "github.com/cosmos/cosmos-sdk/types"
+	paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
+	"github.com/tharsis/ethermint/x/evm/types"
+)
+
+var (
+	NewAllowedMsgs = []types.EIP712AllowedMsg{
+		// x/evmutil
+		{
+			MsgTypeUrl:       "/kava.evmutil.v1beta1.MsgConvertERC20ToCoin",
+			MsgValueTypeName: "MsgValueEVMConvertERC20ToCoin",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "initiator", Type: "string"},
+				{Name: "receiver", Type: "string"},
+				{Name: "kava_erc20_address", Type: "string"},
+				{Name: "amount", Type: "string"},
+			},
+		},
+		{
+			MsgTypeUrl:       "/kava.evmutil.v1beta1.MsgConvertCoinToERC20",
+			MsgValueTypeName: "MsgValueEVMConvertCoinToERC20",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "initiator", Type: "string"},
+				{Name: "receiver", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+			},
+		},
+		// x/earn
+		{
+			MsgTypeUrl:       "/kava.earn.v1beta1.MsgDeposit",
+			MsgValueTypeName: "MsgValueEarnDeposit",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "depositor", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+				{Name: "strategy", Type: "int32"},
+			},
+		},
+		{
+			MsgTypeUrl:       "/kava.earn.v1beta1.MsgWithdraw",
+			MsgValueTypeName: "MsgValueEarnWithdraw",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "from", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+				{Name: "strategy", Type: "int32"},
+			},
+		},
+		// x/staking
+		{
+			MsgTypeUrl:       "/cosmos.staking.v1beta1.MsgDelegate",
+			MsgValueTypeName: "MsgValueStakingDelegate",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "delegator_address", Type: "string"},
+				{Name: "validator_address", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+			},
+		},
+		{
+			MsgTypeUrl:       "/cosmos.staking.v1beta1.MsgUndelegate",
+			MsgValueTypeName: "MsgValueStakingUndelegate",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "delegator_address", Type: "string"},
+				{Name: "validator_address", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+			},
+		},
+		{
+			MsgTypeUrl:       "/cosmos.staking.v1beta1.MsgBeginRedelegate",
+			MsgValueTypeName: "MsgValueStakingBeginRedelegate",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "delegator_address", Type: "string"},
+				{Name: "validator_src_address", Type: "string"},
+				{Name: "validator_dst_address", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+			},
+		},
+		// x/incentive
+		{
+			MsgTypeUrl:       "/kava.incentive.v1beta1.MsgClaimUSDXMintingReward",
+			MsgValueTypeName: "MsgValueIncentiveClaimUSDXMintingReward",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "sender", Type: "string"},
+				{Name: "multiplier_name", Type: "string"},
+			},
+		},
+		{
+			MsgTypeUrl:       "/kava.incentive.v1beta1.MsgClaimHardReward",
+			MsgValueTypeName: "MsgValueIncentiveClaimHardReward",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "sender", Type: "string"},
+				{Name: "denoms_to_claim", Type: "IncentiveSelection"},
+			},
+			NestedTypes: []types.EIP712NestedMsgType{
+				{
+					Name: "IncentiveSelection",
+					Attrs: []types.EIP712MsgAttrType{
+						{Name: "denom", Type: "string"},
+						{Name: "multiplier_name", Type: "string"},
+					},
+				},
+			},
+		},
+		{
+			MsgTypeUrl:       "/kava.incentive.v1beta1.MsgClaimDelegatorReward",
+			MsgValueTypeName: "MsgValueIncentiveClaimDelegatorReward",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "sender", Type: "string"},
+				{Name: "denoms_to_claim", Type: "IncentiveSelection"},
+			},
+			NestedTypes: []types.EIP712NestedMsgType{
+				{
+					Name: "IncentiveSelection",
+					Attrs: []types.EIP712MsgAttrType{
+						{Name: "denom", Type: "string"},
+						{Name: "multiplier_name", Type: "string"},
+					},
+				},
+			},
+		},
+		{
+			MsgTypeUrl:       "/kava.incentive.v1beta1.MsgClaimSwapReward",
+			MsgValueTypeName: "MsgValueIncentiveClaimSwapReward",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "sender", Type: "string"},
+				{Name: "denoms_to_claim", Type: "IncentiveSelection"},
+			},
+			NestedTypes: []types.EIP712NestedMsgType{
+				{
+					Name: "IncentiveSelection",
+					Attrs: []types.EIP712MsgAttrType{
+						{Name: "denom", Type: "string"},
+						{Name: "multiplier_name", Type: "string"},
+					},
+				},
+			},
+		},
+		{
+			MsgTypeUrl:       "/kava.incentive.v1beta1.MsgClaimSavingsReward",
+			MsgValueTypeName: "MsgValueIncentiveClaimSavingsReward",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "sender", Type: "string"},
+				{Name: "denoms_to_claim", Type: "IncentiveSelection"},
+			},
+			NestedTypes: []types.EIP712NestedMsgType{
+				{
+					Name: "IncentiveSelection",
+					Attrs: []types.EIP712MsgAttrType{
+						{Name: "denom", Type: "string"},
+						{Name: "multiplier_name", Type: "string"},
+					},
+				},
+			},
+		},
+		{
+			MsgTypeUrl:       "/kava.incentive.v1beta1.MsgClaimEarnReward",
+			MsgValueTypeName: "MsgValueIncentiveClaimEarnReward",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "sender", Type: "string"},
+				{Name: "denoms_to_claim", Type: "IncentiveSelection"},
+			},
+			NestedTypes: []types.EIP712NestedMsgType{
+				{
+					Name: "IncentiveSelection",
+					Attrs: []types.EIP712MsgAttrType{
+						{Name: "denom", Type: "string"},
+						{Name: "multiplier_name", Type: "string"},
+					},
+				},
+			},
+		},
+		// x/router
+		{
+			MsgTypeUrl:       "/kava.router.v1beta1.MsgMintDeposit",
+			MsgValueTypeName: "MsgValueRouterMintDeposit",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "depositor", Type: "string"},
+				{Name: "validator", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+			},
+		},
+		{
+			MsgTypeUrl:       "/kava.router.v1beta1.MsgDelegateMintDeposit",
+			MsgValueTypeName: "MsgValueRouterDelegateMintDeposit",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "depositor", Type: "string"},
+				{Name: "validator", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+			},
+		},
+		{
+			MsgTypeUrl:       "/kava.router.v1beta1.MsgWithdrawBurn",
+			MsgValueTypeName: "MsgValueRouterWithdrawBurn",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "from", Type: "string"},
+				{Name: "validator", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+			},
+		},
+		{
+			MsgTypeUrl:       "/kava.router.v1beta1.MsgWithdrawBurnUndelegate",
+			MsgValueTypeName: "MsgValueRouterWithdrawBurnUndelegate",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "from", Type: "string"},
+				{Name: "validator", Type: "string"},
+				{Name: "amount", Type: "Coin"},
+			},
+		},
+		// x/gov
+		{
+			MsgTypeUrl:       "/cosmos.gov.v1beta1.MsgVote",
+			MsgValueTypeName: "MsgValueGovVote",
+			ValueTypes: []types.EIP712MsgAttrType{
+				{Name: "proposal_id", Type: "uint64"},
+				{Name: "voter", Type: "string"},
+				{Name: "option", Type: "int32"},
+			},
+		},
+	}
+)
+
+// MigrateStore sets the default AllowUnprotectedTxs parameter.
+func MigrateStore(ctx sdk.Context, paramstore *paramtypes.Subspace) error {
+	if !paramstore.HasKeyTable() {
+		ps := paramstore.WithKeyTable(types.ParamKeyTable())
+		paramstore = &ps
+	}
+	paramstore.Set(ctx, types.ParamStoreKeyEIP712AllowedMsgs, NewAllowedMsgs)
+	return nil
+}
diff --git a/x/evm/migrations/v2/store_test.go b/x/evm/migrations/v2/store_test.go
new file mode 100644
index 00000000..61de1fba
--- /dev/null
+++ b/x/evm/migrations/v2/store_test.go
@@ -0,0 +1,45 @@
+package v2_test
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/cosmos/cosmos-sdk/testutil"
+	sdk "github.com/cosmos/cosmos-sdk/types"
+	"github.com/stretchr/testify/require"
+
+	paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
+	"github.com/tharsis/ethermint/encoding"
+
+	"github.com/tharsis/ethermint/app"
+	v2 "github.com/tharsis/ethermint/x/evm/migrations/v2"
+	v2types "github.com/tharsis/ethermint/x/evm/migrations/v2/types"
+	"github.com/tharsis/ethermint/x/evm/types"
+)
+
+func TestMigrateStore(t *testing.T) {
+	encCfg := encoding.MakeConfig(app.ModuleBasics)
+	kvStoreKey := sdk.NewKVStoreKey(types.StoreKey)
+	tStoreKey := sdk.NewTransientStoreKey(fmt.Sprintf("%s_test", types.StoreKey))
+	ctx := testutil.DefaultContext(kvStoreKey, tStoreKey)
+	paramstore := paramtypes.NewSubspace(
+		encCfg.Marshaler, encCfg.Amino, kvStoreKey, tStoreKey, "evm",
+	).WithKeyTable(v2types.ParamKeyTable())
+	params := v2types.DefaultParams()
+	paramstore.SetParamSet(ctx, &params)
+
+	require.Panics(t, func() {
+		var result []types.EIP712AllowedMsg
+		paramstore.Get(ctx, types.ParamStoreKeyEIP712AllowedMsgs, &result)
+	})
+
+	paramstore = paramtypes.NewSubspace(
+		encCfg.Marshaler, encCfg.Amino, kvStoreKey, tStoreKey, "evm",
+	).WithKeyTable(types.ParamKeyTable())
+	err := v2.MigrateStore(ctx, &paramstore)
+	require.NoError(t, err)
+
+	var result []types.EIP712AllowedMsg
+	paramstore.Get(ctx, types.ParamStoreKeyEIP712AllowedMsgs, &result)
+	require.Equal(t, v2.NewAllowedMsgs, result)
+}
diff --git a/x/evm/migrations/v2/types/chain_config.go b/x/evm/migrations/v2/types/chain_config.go
new file mode 100644
index 00000000..d0f2134a
--- /dev/null
+++ b/x/evm/migrations/v2/types/chain_config.go
@@ -0,0 +1,165 @@
+package types
+
+import (
+	"math/big"
+	"strings"
+
+	sdk "github.com/cosmos/cosmos-sdk/types"
+	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
+
+	"github.com/ethereum/go-ethereum/common"
+	"github.com/ethereum/go-ethereum/params"
+
+	"github.com/tharsis/ethermint/x/evm/types"
+)
+
+// EthereumConfig returns an Ethereum ChainConfig for EVM state transitions.
+// All the negative or nil values are converted to nil
+func (cc ChainConfig) EthereumConfig(chainID *big.Int) *params.ChainConfig {
+	return &params.ChainConfig{
+		ChainID:                 chainID,
+		HomesteadBlock:          getBlockValue(cc.HomesteadBlock),
+		DAOForkBlock:            getBlockValue(cc.DAOForkBlock),
+		DAOForkSupport:          cc.DAOForkSupport,
+		EIP150Block:             getBlockValue(cc.EIP150Block),
+		EIP150Hash:              common.HexToHash(cc.EIP150Hash),
+		EIP155Block:             getBlockValue(cc.EIP155Block),
+		EIP158Block:             getBlockValue(cc.EIP158Block),
+		ByzantiumBlock:          getBlockValue(cc.ByzantiumBlock),
+		ConstantinopleBlock:     getBlockValue(cc.ConstantinopleBlock),
+		PetersburgBlock:         getBlockValue(cc.PetersburgBlock),
+		IstanbulBlock:           getBlockValue(cc.IstanbulBlock),
+		MuirGlacierBlock:        getBlockValue(cc.MuirGlacierBlock),
+		BerlinBlock:             getBlockValue(cc.BerlinBlock),
+		LondonBlock:             getBlockValue(cc.LondonBlock),
+		ArrowGlacierBlock:       getBlockValue(cc.ArrowGlacierBlock),
+		MergeForkBlock:          getBlockValue(cc.MergeForkBlock),
+		TerminalTotalDifficulty: nil,
+		Ethash:                  nil,
+		Clique:                  nil,
+	}
+}
+
+// DefaultChainConfig returns default evm parameters.
+func DefaultChainConfig() ChainConfig {
+	homesteadBlock := sdk.ZeroInt()
+	daoForkBlock := sdk.ZeroInt()
+	eip150Block := sdk.ZeroInt()
+	eip155Block := sdk.ZeroInt()
+	eip158Block := sdk.ZeroInt()
+	byzantiumBlock := sdk.ZeroInt()
+	constantinopleBlock := sdk.ZeroInt()
+	petersburgBlock := sdk.ZeroInt()
+	istanbulBlock := sdk.ZeroInt()
+	muirGlacierBlock := sdk.ZeroInt()
+	berlinBlock := sdk.ZeroInt()
+	londonBlock := sdk.ZeroInt()
+	arrowGlacierBlock := sdk.ZeroInt()
+	mergeForkBlock := sdk.ZeroInt()
+
+	return ChainConfig{
+		HomesteadBlock:      &homesteadBlock,
+		DAOForkBlock:        &daoForkBlock,
+		DAOForkSupport:      true,
+		EIP150Block:         &eip150Block,
+		EIP150Hash:          common.Hash{}.String(),
+		EIP155Block:         &eip155Block,
+		EIP158Block:         &eip158Block,
+		ByzantiumBlock:      &byzantiumBlock,
+		ConstantinopleBlock: &constantinopleBlock,
+		PetersburgBlock:     &petersburgBlock,
+		IstanbulBlock:       &istanbulBlock,
+		MuirGlacierBlock:    &muirGlacierBlock,
+		BerlinBlock:         &berlinBlock,
+		LondonBlock:         &londonBlock,
+		ArrowGlacierBlock:   &arrowGlacierBlock,
+		MergeForkBlock:      &mergeForkBlock,
+	}
+}
+
+func getBlockValue(block *sdk.Int) *big.Int {
+	if block == nil || block.IsNegative() {
+		return nil
+	}
+
+	return block.BigInt()
+}
+
+// Validate performs a basic validation of the ChainConfig params. The function will return an error
+// if any of the block values is uninitialized (i.e nil) or if the EIP150Hash is an invalid hash.
+func (cc ChainConfig) Validate() error {
+	if err := validateBlock(cc.HomesteadBlock); err != nil {
+		return sdkerrors.Wrap(err, "homesteadBlock")
+	}
+	if err := validateBlock(cc.DAOForkBlock); err != nil {
+		return sdkerrors.Wrap(err, "daoForkBlock")
+	}
+	if err := validateBlock(cc.EIP150Block); err != nil {
+		return sdkerrors.Wrap(err, "eip150Block")
+	}
+	if err := validateHash(cc.EIP150Hash); err != nil {
+		return err
+	}
+	if err := validateBlock(cc.EIP155Block); err != nil {
+		return sdkerrors.Wrap(err, "eip155Block")
+	}
+	if err := validateBlock(cc.EIP158Block); err != nil {
+		return sdkerrors.Wrap(err, "eip158Block")
+	}
+	if err := validateBlock(cc.ByzantiumBlock); err != nil {
+		return sdkerrors.Wrap(err, "byzantiumBlock")
+	}
+	if err := validateBlock(cc.ConstantinopleBlock); err != nil {
+		return sdkerrors.Wrap(err, "constantinopleBlock")
+	}
+	if err := validateBlock(cc.PetersburgBlock); err != nil {
+		return sdkerrors.Wrap(err, "petersburgBlock")
+	}
+	if err := validateBlock(cc.IstanbulBlock); err != nil {
+		return sdkerrors.Wrap(err, "istanbulBlock")
+	}
+	if err := validateBlock(cc.MuirGlacierBlock); err != nil {
+		return sdkerrors.Wrap(err, "muirGlacierBlock")
+	}
+	if err := validateBlock(cc.BerlinBlock); err != nil {
+		return sdkerrors.Wrap(err, "berlinBlock")
+	}
+	if err := validateBlock(cc.LondonBlock); err != nil {
+		return sdkerrors.Wrap(err, "londonBlock")
+	}
+	if err := validateBlock(cc.ArrowGlacierBlock); err != nil {
+		return sdkerrors.Wrap(err, "arrowGlacierBlock")
+	}
+	if err := validateBlock(cc.MergeForkBlock); err != nil {
+		return sdkerrors.Wrap(err, "mergeForkBlock")
+	}
+
+	// NOTE: chain ID is not needed to check config order
+	if err := cc.EthereumConfig(nil).CheckConfigForkOrder(); err != nil {
+		return sdkerrors.Wrap(err, "invalid config fork order")
+	}
+	return nil
+}
+
+func validateHash(hex string) error {
+	if hex != "" && strings.TrimSpace(hex) == "" {
+		return sdkerrors.Wrap(types.ErrInvalidChainConfig, "hash cannot be blank")
+	}
+
+	return nil
+}
+
+func validateBlock(block *sdk.Int) error {
+	// nil value means that the fork has not yet been applied
+	if block == nil {
+		return nil
+	}
+
+	if block.IsNegative() {
+		return sdkerrors.Wrapf(
+			types.ErrInvalidChainConfig, "block value cannot be negative: %s", block,
+		)
+	}
+
+	return nil
+}
diff --git a/x/evm/migrations/v2/types/evm.pb.go b/x/evm/migrations/v2/types/evm.pb.go
new file mode 100644
index 00000000..f214beaf
--- /dev/null
+++ b/x/evm/migrations/v2/types/evm.pb.go
@@ -0,0 +1,4664 @@
+// Code generated by protoc-gen-gogo. DO NOT EDIT.
+// source: ethermint/evm/v1/evm.proto
+
+package types
+
+import (
+	fmt "fmt"
+	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
+	_ "github.com/gogo/protobuf/gogoproto"
+	proto "github.com/gogo/protobuf/proto"
+	io "io"
+	math "math"
+	math_bits "math/bits"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// This is a compile-time assertion to ensure that this generated file
+// is compatible with the proto package it is being compiled against.
+// A compilation error at this line likely means your copy of the
+// proto package needs to be updated.
+const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package
+
+// Params defines the EVM module parameters
+type Params struct {
+	// evm denom represents the token denomination used to run the EVM state
+	// transitions.
+	EvmDenom string `protobuf:"bytes,1,opt,name=evm_denom,json=evmDenom,proto3" json:"evm_denom,omitempty" yaml:"evm_denom"`
+	// enable create toggles state transitions that use the vm.Create function
+	EnableCreate bool `protobuf:"varint,2,opt,name=enable_create,json=enableCreate,proto3" json:"enable_create,omitempty" yaml:"enable_create"`
+	// enable call toggles state transitions that use the vm.Call function
+	EnableCall bool `protobuf:"varint,3,opt,name=enable_call,json=enableCall,proto3" json:"enable_call,omitempty" yaml:"enable_call"`
+	// extra eips defines the additional EIPs for the vm.Config
+	ExtraEIPs []int64 `protobuf:"varint,4,rep,packed,name=extra_eips,json=extraEips,proto3" json:"extra_eips,omitempty" yaml:"extra_eips"`
+	// chain config defines the EVM chain configuration parameters
+	ChainConfig ChainConfig `protobuf:"bytes,5,opt,name=chain_config,json=chainConfig,proto3" json:"chain_config" yaml:"chain_config"`
+	// list of allowed eip712 msgs and their types
+	EIP712AllowedMsgs []EIP712AllowedMsg `protobuf:"bytes,6,rep,name=eip712_allowed_msgs,json=eip712AllowedMsgs,proto3" json:"eip712_allowed_msgs"`
+}
+
+func (m *Params) Reset()         { *m = Params{} }
+func (m *Params) String() string { return proto.CompactTextString(m) }
+func (*Params) ProtoMessage()    {}
+func (*Params) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{0}
+}
+func (m *Params) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *Params) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_Params.Merge(m, src)
+}
+func (m *Params) XXX_Size() int {
+	return m.Size()
+}
+func (m *Params) XXX_DiscardUnknown() {
+	xxx_messageInfo_Params.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_Params proto.InternalMessageInfo
+
+func (m *Params) GetEvmDenom() string {
+	if m != nil {
+		return m.EvmDenom
+	}
+	return ""
+}
+
+func (m *Params) GetEnableCreate() bool {
+	if m != nil {
+		return m.EnableCreate
+	}
+	return false
+}
+
+func (m *Params) GetEnableCall() bool {
+	if m != nil {
+		return m.EnableCall
+	}
+	return false
+}
+
+func (m *Params) GetExtraEIPs() []int64 {
+	if m != nil {
+		return m.ExtraEIPs
+	}
+	return nil
+}
+
+func (m *Params) GetChainConfig() ChainConfig {
+	if m != nil {
+		return m.ChainConfig
+	}
+	return ChainConfig{}
+}
+
+func (m *Params) GetEIP712AllowedMsgs() []EIP712AllowedMsg {
+	if m != nil {
+		return m.EIP712AllowedMsgs
+	}
+	return nil
+}
+
+// ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
+// instead of *big.Int.
+type ChainConfig struct {
+	// Homestead switch block (nil no fork, 0 = already homestead)
+	HomesteadBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=homestead_block,json=homesteadBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"homestead_block,omitempty" yaml:"homestead_block"`
+	// TheDAO hard-fork switch block (nil no fork)
+	DAOForkBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=dao_fork_block,json=daoForkBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"dao_fork_block,omitempty" yaml:"dao_fork_block"`
+	// Whether the nodes supports or opposes the DAO hard-fork
+	DAOForkSupport bool `protobuf:"varint,3,opt,name=dao_fork_support,json=daoForkSupport,proto3" json:"dao_fork_support,omitempty" yaml:"dao_fork_support"`
+	// EIP150 implements the Gas price changes
+	// (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
+	EIP150Block *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=eip150_block,json=eip150Block,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"eip150_block,omitempty" yaml:"eip150_block"`
+	// EIP150 HF hash (needed for header only clients as only gas pricing changed)
+	EIP150Hash string `protobuf:"bytes,5,opt,name=eip150_hash,json=eip150Hash,proto3" json:"eip150_hash,omitempty" yaml:"byzantium_block"`
+	// EIP155Block HF block
+	EIP155Block *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,6,opt,name=eip155_block,json=eip155Block,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"eip155_block,omitempty" yaml:"eip155_block"`
+	// EIP158 HF block
+	EIP158Block *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,7,opt,name=eip158_block,json=eip158Block,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"eip158_block,omitempty" yaml:"eip158_block"`
+	// Byzantium switch block (nil no fork, 0 = already on byzantium)
+	ByzantiumBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,8,opt,name=byzantium_block,json=byzantiumBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"byzantium_block,omitempty" yaml:"byzantium_block"`
+	// Constantinople switch block (nil no fork, 0 = already activated)
+	ConstantinopleBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,9,opt,name=constantinople_block,json=constantinopleBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"constantinople_block,omitempty" yaml:"constantinople_block"`
+	// Petersburg switch block (nil same as Constantinople)
+	PetersburgBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,10,opt,name=petersburg_block,json=petersburgBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"petersburg_block,omitempty" yaml:"petersburg_block"`
+	// Istanbul switch block (nil no fork, 0 = already on istanbul)
+	IstanbulBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,11,opt,name=istanbul_block,json=istanbulBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"istanbul_block,omitempty" yaml:"istanbul_block"`
+	// Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)
+	MuirGlacierBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,12,opt,name=muir_glacier_block,json=muirGlacierBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"muir_glacier_block,omitempty" yaml:"muir_glacier_block"`
+	// Berlin switch block (nil = no fork, 0 = already on berlin)
+	BerlinBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,13,opt,name=berlin_block,json=berlinBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"berlin_block,omitempty" yaml:"berlin_block"`
+	// London switch block (nil = no fork, 0 = already on london)
+	LondonBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,17,opt,name=london_block,json=londonBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"london_block,omitempty" yaml:"london_block"`
+	// Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)
+	ArrowGlacierBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,18,opt,name=arrow_glacier_block,json=arrowGlacierBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"arrow_glacier_block,omitempty" yaml:"arrow_glacier_block"`
+	// EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings)
+	MergeForkBlock *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,19,opt,name=merge_fork_block,json=mergeForkBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"merge_fork_block,omitempty" yaml:"merge_fork_block"`
+}
+
+func (m *ChainConfig) Reset()         { *m = ChainConfig{} }
+func (m *ChainConfig) String() string { return proto.CompactTextString(m) }
+func (*ChainConfig) ProtoMessage()    {}
+func (*ChainConfig) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{1}
+}
+func (m *ChainConfig) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *ChainConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_ChainConfig.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *ChainConfig) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_ChainConfig.Merge(m, src)
+}
+func (m *ChainConfig) XXX_Size() int {
+	return m.Size()
+}
+func (m *ChainConfig) XXX_DiscardUnknown() {
+	xxx_messageInfo_ChainConfig.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_ChainConfig proto.InternalMessageInfo
+
+func (m *ChainConfig) GetDAOForkSupport() bool {
+	if m != nil {
+		return m.DAOForkSupport
+	}
+	return false
+}
+
+func (m *ChainConfig) GetEIP150Hash() string {
+	if m != nil {
+		return m.EIP150Hash
+	}
+	return ""
+}
+
+// State represents a single Storage key value pair item.
+type State struct {
+	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
+	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
+}
+
+func (m *State) Reset()         { *m = State{} }
+func (m *State) String() string { return proto.CompactTextString(m) }
+func (*State) ProtoMessage()    {}
+func (*State) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{2}
+}
+func (m *State) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *State) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_State.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *State) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_State.Merge(m, src)
+}
+func (m *State) XXX_Size() int {
+	return m.Size()
+}
+func (m *State) XXX_DiscardUnknown() {
+	xxx_messageInfo_State.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_State proto.InternalMessageInfo
+
+func (m *State) GetKey() string {
+	if m != nil {
+		return m.Key
+	}
+	return ""
+}
+
+func (m *State) GetValue() string {
+	if m != nil {
+		return m.Value
+	}
+	return ""
+}
+
+// TransactionLogs define the logs generated from a transaction execution
+// with a given hash. It it used for import/export data as transactions are not
+// persisted on blockchain state after an upgrade.
+type TransactionLogs struct {
+	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
+	Logs []*Log `protobuf:"bytes,2,rep,name=logs,proto3" json:"logs,omitempty"`
+}
+
+func (m *TransactionLogs) Reset()         { *m = TransactionLogs{} }
+func (m *TransactionLogs) String() string { return proto.CompactTextString(m) }
+func (*TransactionLogs) ProtoMessage()    {}
+func (*TransactionLogs) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{3}
+}
+func (m *TransactionLogs) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *TransactionLogs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_TransactionLogs.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *TransactionLogs) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_TransactionLogs.Merge(m, src)
+}
+func (m *TransactionLogs) XXX_Size() int {
+	return m.Size()
+}
+func (m *TransactionLogs) XXX_DiscardUnknown() {
+	xxx_messageInfo_TransactionLogs.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_TransactionLogs proto.InternalMessageInfo
+
+func (m *TransactionLogs) GetHash() string {
+	if m != nil {
+		return m.Hash
+	}
+	return ""
+}
+
+func (m *TransactionLogs) GetLogs() []*Log {
+	if m != nil {
+		return m.Logs
+	}
+	return nil
+}
+
+// Log represents an protobuf compatible Ethereum Log that defines a contract
+// log event. These events are generated by the LOG opcode and stored/indexed by
+// the node.
+type Log struct {
+	// address of the contract that generated the event
+	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
+	// list of topics provided by the contract.
+	Topics []string `protobuf:"bytes,2,rep,name=topics,proto3" json:"topics,omitempty"`
+	// supplied by the contract, usually ABI-encoded
+	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
+	// block in which the transaction was included
+	BlockNumber uint64 `protobuf:"varint,4,opt,name=block_number,json=blockNumber,proto3" json:"blockNumber"`
+	// hash of the transaction
+	TxHash string `protobuf:"bytes,5,opt,name=tx_hash,json=txHash,proto3" json:"transactionHash"`
+	// index of the transaction in the block
+	TxIndex uint64 `protobuf:"varint,6,opt,name=tx_index,json=txIndex,proto3" json:"transactionIndex"`
+	// hash of the block in which the transaction was included
+	BlockHash string `protobuf:"bytes,7,opt,name=block_hash,json=blockHash,proto3" json:"blockHash"`
+	// index of the log in the block
+	Index uint64 `protobuf:"varint,8,opt,name=index,proto3" json:"logIndex"`
+	// The Removed field is true if this log was reverted due to a chain
+	// reorganisation. You must pay attention to this field if you receive logs
+	// through a filter query.
+	Removed bool `protobuf:"varint,9,opt,name=removed,proto3" json:"removed,omitempty"`
+}
+
+func (m *Log) Reset()         { *m = Log{} }
+func (m *Log) String() string { return proto.CompactTextString(m) }
+func (*Log) ProtoMessage()    {}
+func (*Log) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{4}
+}
+func (m *Log) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *Log) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_Log.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *Log) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_Log.Merge(m, src)
+}
+func (m *Log) XXX_Size() int {
+	return m.Size()
+}
+func (m *Log) XXX_DiscardUnknown() {
+	xxx_messageInfo_Log.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_Log proto.InternalMessageInfo
+
+func (m *Log) GetAddress() string {
+	if m != nil {
+		return m.Address
+	}
+	return ""
+}
+
+func (m *Log) GetTopics() []string {
+	if m != nil {
+		return m.Topics
+	}
+	return nil
+}
+
+func (m *Log) GetData() []byte {
+	if m != nil {
+		return m.Data
+	}
+	return nil
+}
+
+func (m *Log) GetBlockNumber() uint64 {
+	if m != nil {
+		return m.BlockNumber
+	}
+	return 0
+}
+
+func (m *Log) GetTxHash() string {
+	if m != nil {
+		return m.TxHash
+	}
+	return ""
+}
+
+func (m *Log) GetTxIndex() uint64 {
+	if m != nil {
+		return m.TxIndex
+	}
+	return 0
+}
+
+func (m *Log) GetBlockHash() string {
+	if m != nil {
+		return m.BlockHash
+	}
+	return ""
+}
+
+func (m *Log) GetIndex() uint64 {
+	if m != nil {
+		return m.Index
+	}
+	return 0
+}
+
+func (m *Log) GetRemoved() bool {
+	if m != nil {
+		return m.Removed
+	}
+	return false
+}
+
+// TxResult stores results of Tx execution.
+type TxResult struct {
+	// contract_address contains the ethereum address of the created contract (if
+	// any). If the state transition is an evm.Call, the contract address will be
+	// empty.
+	ContractAddress string `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty" yaml:"contract_address"`
+	// bloom represents the bloom filter bytes
+	Bloom []byte `protobuf:"bytes,2,opt,name=bloom,proto3" json:"bloom,omitempty"`
+	// tx_logs contains the transaction hash and the proto-compatible ethereum
+	// logs.
+	TxLogs TransactionLogs `protobuf:"bytes,3,opt,name=tx_logs,json=txLogs,proto3" json:"tx_logs" yaml:"tx_logs"`
+	// ret defines the bytes from the execution.
+	Ret []byte `protobuf:"bytes,4,opt,name=ret,proto3" json:"ret,omitempty"`
+	// reverted flag is set to true when the call has been reverted
+	Reverted bool `protobuf:"varint,5,opt,name=reverted,proto3" json:"reverted,omitempty"`
+	// gas_used notes the amount of gas consumed while execution
+	GasUsed uint64 `protobuf:"varint,6,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
+}
+
+func (m *TxResult) Reset()         { *m = TxResult{} }
+func (m *TxResult) String() string { return proto.CompactTextString(m) }
+func (*TxResult) ProtoMessage()    {}
+func (*TxResult) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{5}
+}
+func (m *TxResult) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *TxResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_TxResult.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *TxResult) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_TxResult.Merge(m, src)
+}
+func (m *TxResult) XXX_Size() int {
+	return m.Size()
+}
+func (m *TxResult) XXX_DiscardUnknown() {
+	xxx_messageInfo_TxResult.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_TxResult proto.InternalMessageInfo
+
+// AccessTuple is the element type of an access list.
+type AccessTuple struct {
+	// hex formatted ethereum address
+	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
+	// hex formatted hashes of the storage keys
+	StorageKeys []string `protobuf:"bytes,2,rep,name=storage_keys,json=storageKeys,proto3" json:"storageKeys"`
+}
+
+func (m *AccessTuple) Reset()         { *m = AccessTuple{} }
+func (m *AccessTuple) String() string { return proto.CompactTextString(m) }
+func (*AccessTuple) ProtoMessage()    {}
+func (*AccessTuple) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{6}
+}
+func (m *AccessTuple) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *AccessTuple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_AccessTuple.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *AccessTuple) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_AccessTuple.Merge(m, src)
+}
+func (m *AccessTuple) XXX_Size() int {
+	return m.Size()
+}
+func (m *AccessTuple) XXX_DiscardUnknown() {
+	xxx_messageInfo_AccessTuple.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_AccessTuple proto.InternalMessageInfo
+
+// TraceConfig holds extra parameters to trace functions.
+type TraceConfig struct {
+	// custom javascript tracer
+	Tracer string `protobuf:"bytes,1,opt,name=tracer,proto3" json:"tracer,omitempty"`
+	// overrides the default timeout of 5 seconds for JavaScript-based tracing
+	// calls
+	Timeout string `protobuf:"bytes,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
+	// number of blocks the tracer is willing to go back
+	Reexec uint64 `protobuf:"varint,3,opt,name=reexec,proto3" json:"reexec,omitempty"`
+	// disable stack capture
+	DisableStack bool `protobuf:"varint,5,opt,name=disable_stack,json=disableStack,proto3" json:"disableStack"`
+	// disable storage capture
+	DisableStorage bool `protobuf:"varint,6,opt,name=disable_storage,json=disableStorage,proto3" json:"disableStorage"`
+	// print output during capture end
+	Debug bool `protobuf:"varint,8,opt,name=debug,proto3" json:"debug,omitempty"`
+	// maximum length of output, but zero means unlimited
+	Limit int32 `protobuf:"varint,9,opt,name=limit,proto3" json:"limit,omitempty"`
+	// Chain overrides, can be used to execute a trace using future fork rules
+	Overrides *ChainConfig `protobuf:"bytes,10,opt,name=overrides,proto3" json:"overrides,omitempty"`
+	// enable memory capture
+	EnableMemory bool `protobuf:"varint,11,opt,name=enable_memory,json=enableMemory,proto3" json:"enableMemory"`
+	// enable return data capture
+	EnableReturnData bool `protobuf:"varint,12,opt,name=enable_return_data,json=enableReturnData,proto3" json:"enableReturnData"`
+}
+
+func (m *TraceConfig) Reset()         { *m = TraceConfig{} }
+func (m *TraceConfig) String() string { return proto.CompactTextString(m) }
+func (*TraceConfig) ProtoMessage()    {}
+func (*TraceConfig) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{7}
+}
+func (m *TraceConfig) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *TraceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_TraceConfig.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *TraceConfig) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_TraceConfig.Merge(m, src)
+}
+func (m *TraceConfig) XXX_Size() int {
+	return m.Size()
+}
+func (m *TraceConfig) XXX_DiscardUnknown() {
+	xxx_messageInfo_TraceConfig.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_TraceConfig proto.InternalMessageInfo
+
+func (m *TraceConfig) GetTracer() string {
+	if m != nil {
+		return m.Tracer
+	}
+	return ""
+}
+
+func (m *TraceConfig) GetTimeout() string {
+	if m != nil {
+		return m.Timeout
+	}
+	return ""
+}
+
+func (m *TraceConfig) GetReexec() uint64 {
+	if m != nil {
+		return m.Reexec
+	}
+	return 0
+}
+
+func (m *TraceConfig) GetDisableStack() bool {
+	if m != nil {
+		return m.DisableStack
+	}
+	return false
+}
+
+func (m *TraceConfig) GetDisableStorage() bool {
+	if m != nil {
+		return m.DisableStorage
+	}
+	return false
+}
+
+func (m *TraceConfig) GetDebug() bool {
+	if m != nil {
+		return m.Debug
+	}
+	return false
+}
+
+func (m *TraceConfig) GetLimit() int32 {
+	if m != nil {
+		return m.Limit
+	}
+	return 0
+}
+
+func (m *TraceConfig) GetOverrides() *ChainConfig {
+	if m != nil {
+		return m.Overrides
+	}
+	return nil
+}
+
+func (m *TraceConfig) GetEnableMemory() bool {
+	if m != nil {
+		return m.EnableMemory
+	}
+	return false
+}
+
+func (m *TraceConfig) GetEnableReturnData() bool {
+	if m != nil {
+		return m.EnableReturnData
+	}
+	return false
+}
+
+// EIP712AllowedMsg stores an allowed legacy msg and its eip712 type.
+type EIP712AllowedMsg struct {
+	// msg's proto type name. ie "/cosmos.bank.v1beta1.MsgSend"
+	MsgTypeUrl string `protobuf:"bytes,1,opt,name=msg_type_url,json=msgTypeUrl,proto3" json:"msg_type_url,omitempty"`
+	// name of the eip712 value type. ie "MsgValueSend"
+	MsgValueTypeName string `protobuf:"bytes,2,opt,name=msg_value_type_name,json=msgValueTypeName,proto3" json:"msg_value_type_name,omitempty"`
+	// types of the msg value
+	ValueTypes []EIP712MsgAttrType `protobuf:"bytes,3,rep,name=value_types,json=valueTypes,proto3" json:"value_types"`
+	// nested types of the msg value
+	NestedTypes []EIP712NestedMsgType `protobuf:"bytes,4,rep,name=nested_types,json=nestedTypes,proto3" json:"nested_types"`
+}
+
+func (m *EIP712AllowedMsg) Reset()         { *m = EIP712AllowedMsg{} }
+func (m *EIP712AllowedMsg) String() string { return proto.CompactTextString(m) }
+func (*EIP712AllowedMsg) ProtoMessage()    {}
+func (*EIP712AllowedMsg) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{8}
+}
+func (m *EIP712AllowedMsg) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *EIP712AllowedMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_EIP712AllowedMsg.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *EIP712AllowedMsg) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_EIP712AllowedMsg.Merge(m, src)
+}
+func (m *EIP712AllowedMsg) XXX_Size() int {
+	return m.Size()
+}
+func (m *EIP712AllowedMsg) XXX_DiscardUnknown() {
+	xxx_messageInfo_EIP712AllowedMsg.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_EIP712AllowedMsg proto.InternalMessageInfo
+
+func (m *EIP712AllowedMsg) GetMsgTypeUrl() string {
+	if m != nil {
+		return m.MsgTypeUrl
+	}
+	return ""
+}
+
+func (m *EIP712AllowedMsg) GetMsgValueTypeName() string {
+	if m != nil {
+		return m.MsgValueTypeName
+	}
+	return ""
+}
+
+func (m *EIP712AllowedMsg) GetValueTypes() []EIP712MsgAttrType {
+	if m != nil {
+		return m.ValueTypes
+	}
+	return nil
+}
+
+func (m *EIP712AllowedMsg) GetNestedTypes() []EIP712NestedMsgType {
+	if m != nil {
+		return m.NestedTypes
+	}
+	return nil
+}
+
+// EIP712MsgType is the eip712 type of a single message.
+type EIP712NestedMsgType struct {
+	// name of the nested type. ie "Fee", "Coin"
+	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	// attrs of the nested type
+	Attrs []EIP712MsgAttrType `protobuf:"bytes,2,rep,name=attrs,proto3" json:"attrs"`
+}
+
+func (m *EIP712NestedMsgType) Reset()         { *m = EIP712NestedMsgType{} }
+func (m *EIP712NestedMsgType) String() string { return proto.CompactTextString(m) }
+func (*EIP712NestedMsgType) ProtoMessage()    {}
+func (*EIP712NestedMsgType) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{9}
+}
+func (m *EIP712NestedMsgType) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *EIP712NestedMsgType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_EIP712NestedMsgType.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *EIP712NestedMsgType) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_EIP712NestedMsgType.Merge(m, src)
+}
+func (m *EIP712NestedMsgType) XXX_Size() int {
+	return m.Size()
+}
+func (m *EIP712NestedMsgType) XXX_DiscardUnknown() {
+	xxx_messageInfo_EIP712NestedMsgType.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_EIP712NestedMsgType proto.InternalMessageInfo
+
+func (m *EIP712NestedMsgType) GetName() string {
+	if m != nil {
+		return m.Name
+	}
+	return ""
+}
+
+func (m *EIP712NestedMsgType) GetAttrs() []EIP712MsgAttrType {
+	if m != nil {
+		return m.Attrs
+	}
+	return nil
+}
+
+// EIP712MsgAttrType is the eip712 type of a single message attribute.
+type EIP712MsgAttrType struct {
+	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
+}
+
+func (m *EIP712MsgAttrType) Reset()         { *m = EIP712MsgAttrType{} }
+func (m *EIP712MsgAttrType) String() string { return proto.CompactTextString(m) }
+func (*EIP712MsgAttrType) ProtoMessage()    {}
+func (*EIP712MsgAttrType) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{10}
+}
+func (m *EIP712MsgAttrType) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *EIP712MsgAttrType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_EIP712MsgAttrType.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *EIP712MsgAttrType) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_EIP712MsgAttrType.Merge(m, src)
+}
+func (m *EIP712MsgAttrType) XXX_Size() int {
+	return m.Size()
+}
+func (m *EIP712MsgAttrType) XXX_DiscardUnknown() {
+	xxx_messageInfo_EIP712MsgAttrType.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_EIP712MsgAttrType proto.InternalMessageInfo
+
+func (m *EIP712MsgAttrType) GetName() string {
+	if m != nil {
+		return m.Name
+	}
+	return ""
+}
+
+func (m *EIP712MsgAttrType) GetType() string {
+	if m != nil {
+		return m.Type
+	}
+	return ""
+}
+
+func init() {
+	proto.RegisterType((*Params)(nil), "ethermint.evm.v1.Params")
+	proto.RegisterType((*ChainConfig)(nil), "ethermint.evm.v1.ChainConfig")
+	proto.RegisterType((*State)(nil), "ethermint.evm.v1.State")
+	proto.RegisterType((*TransactionLogs)(nil), "ethermint.evm.v1.TransactionLogs")
+	proto.RegisterType((*Log)(nil), "ethermint.evm.v1.Log")
+	proto.RegisterType((*TxResult)(nil), "ethermint.evm.v1.TxResult")
+	proto.RegisterType((*AccessTuple)(nil), "ethermint.evm.v1.AccessTuple")
+	proto.RegisterType((*TraceConfig)(nil), "ethermint.evm.v1.TraceConfig")
+	proto.RegisterType((*EIP712AllowedMsg)(nil), "ethermint.evm.v1.EIP712AllowedMsg")
+	proto.RegisterType((*EIP712NestedMsgType)(nil), "ethermint.evm.v1.EIP712NestedMsgType")
+	proto.RegisterType((*EIP712MsgAttrType)(nil), "ethermint.evm.v1.EIP712MsgAttrType")
+}
+
+func init() { proto.RegisterFile("ethermint/evm/v1/evm.proto", fileDescriptor_d21ecc92c8c8583e) }
+
+var fileDescriptor_d21ecc92c8c8583e = []byte{
+	// 1683 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0xdd, 0x4e, 0xe4, 0xc8,
+	0x15, 0x06, 0xda, 0x80, 0xbb, 0xda, 0x74, 0x9b, 0x6a, 0x76, 0xd2, 0x33, 0xa3, 0x60, 0xe2, 0x28,
+	0x11, 0x91, 0x76, 0x60, 0x61, 0x85, 0x66, 0xb4, 0xa3, 0x28, 0xc2, 0x0c, 0xbb, 0x0b, 0x99, 0x99,
+	0xa0, 0x82, 0x4d, 0xa4, 0x48, 0x91, 0x55, 0x6d, 0xd7, 0x1a, 0x2f, 0xb6, 0xab, 0x55, 0x55, 0xdd,
+	0xd3, 0x1d, 0xe5, 0x01, 0x22, 0xe5, 0x26, 0x8f, 0x90, 0x57, 0xc8, 0x3b, 0xe4, 0x62, 0x95, 0xab,
+	0xbd, 0x8c, 0x72, 0x61, 0xad, 0x98, 0x3b, 0x2e, 0x79, 0x81, 0x44, 0xf5, 0xd3, 0xbf, 0x30, 0xc9,
+	0x36, 0x57, 0x5d, 0xe7, 0xef, 0xfb, 0xea, 0x9c, 0x3a, 0xae, 0x63, 0x37, 0x78, 0x42, 0xc4, 0x25,
+	0x61, 0x79, 0x5a, 0x88, 0x5d, 0xd2, 0xcb, 0x77, 0x7b, 0x7b, 0xf2, 0x67, 0xa7, 0xc3, 0xa8, 0xa0,
+	0xd0, 0x1d, 0xd9, 0x76, 0xa4, 0xb2, 0xb7, 0xf7, 0x64, 0x23, 0xa1, 0x09, 0x55, 0xc6, 0x5d, 0xb9,
+	0xd2, 0x7e, 0xfe, 0x3f, 0x2a, 0x60, 0xe5, 0x0c, 0x33, 0x9c, 0x73, 0xb8, 0x07, 0xaa, 0xa4, 0x97,
+	0x87, 0x31, 0x29, 0x68, 0xde, 0x5a, 0xdc, 0x5a, 0xdc, 0xae, 0x06, 0x1b, 0xb7, 0xa5, 0xe7, 0x0e,
+	0x70, 0x9e, 0x7d, 0xe6, 0x8f, 0x4c, 0x3e, 0xb2, 0x49, 0x2f, 0x7f, 0x25, 0x97, 0xf0, 0x97, 0x60,
+	0x8d, 0x14, 0xb8, 0x9d, 0x91, 0x30, 0x62, 0x04, 0x0b, 0xd2, 0x5a, 0xda, 0x5a, 0xdc, 0xb6, 0x83,
+	0xd6, 0x6d, 0xe9, 0x6d, 0x98, 0xb0, 0x49, 0xb3, 0x8f, 0x1c, 0x2d, 0x1f, 0x29, 0x11, 0x3e, 0x07,
+	0xb5, 0xa1, 0x1d, 0x67, 0x59, 0xab, 0xa2, 0x82, 0x1f, 0xdd, 0x96, 0x1e, 0x9c, 0x0e, 0xc6, 0x59,
+	0xe6, 0x23, 0x60, 0x42, 0x71, 0x96, 0xc1, 0x43, 0x00, 0x48, 0x5f, 0x30, 0x1c, 0x92, 0xb4, 0xc3,
+	0x5b, 0xd6, 0x56, 0x65, 0xbb, 0x12, 0xf8, 0xd7, 0xa5, 0x57, 0x3d, 0x96, 0xda, 0xe3, 0x93, 0x33,
+	0x7e, 0x5b, 0x7a, 0xeb, 0x06, 0x64, 0xe4, 0xe8, 0xa3, 0xaa, 0x12, 0x8e, 0xd3, 0x0e, 0x87, 0x7f,
+	0x00, 0x4e, 0x74, 0x89, 0xd3, 0x22, 0x8c, 0x68, 0xf1, 0x75, 0x9a, 0xb4, 0x96, 0xb7, 0x16, 0xb7,
+	0x6b, 0xfb, 0x3f, 0xde, 0x99, 0xad, 0xdb, 0xce, 0x91, 0xf4, 0x3a, 0x52, 0x4e, 0xc1, 0xd3, 0x6f,
+	0x4b, 0x6f, 0xe1, 0xb6, 0xf4, 0x9a, 0x1a, 0x7a, 0x12, 0xc0, 0x47, 0xb5, 0x68, 0xec, 0x09, 0x73,
+	0xd0, 0x24, 0x69, 0xe7, 0xf9, 0xde, 0x7e, 0x88, 0xb3, 0x8c, 0xbe, 0x23, 0x71, 0x98, 0xf3, 0x84,
+	0xb7, 0x56, 0xb6, 0x2a, 0xdb, 0xb5, 0x7d, 0xff, 0x2e, 0xcb, 0xf1, 0xc9, 0xd9, 0xf3, 0xbd, 0xfd,
+	0x43, 0xed, 0xfb, 0x86, 0x27, 0xc1, 0x63, 0x49, 0x75, 0x5d, 0x7a, 0xeb, 0xb3, 0x16, 0x8e, 0xd6,
+	0x35, 0xf2, 0x84, 0xca, 0xff, 0x7b, 0x1d, 0xd4, 0x8e, 0xa6, 0xe8, 0x1b, 0x97, 0x34, 0x27, 0x5c,
+	0x10, 0x1c, 0x87, 0xed, 0x8c, 0x46, 0x57, 0xe6, 0x44, 0x5f, 0xfd, 0xbb, 0xf4, 0x7e, 0x9e, 0xa4,
+	0xe2, 0xb2, 0xdb, 0xde, 0x89, 0x68, 0xbe, 0x1b, 0x51, 0x9e, 0x53, 0x6e, 0x7e, 0x9e, 0xf1, 0xf8,
+	0x6a, 0x57, 0x0c, 0x3a, 0x84, 0xef, 0x9c, 0x14, 0xe2, 0xb6, 0xf4, 0x1e, 0xe9, 0x3c, 0x67, 0xa0,
+	0x7c, 0x54, 0x1f, 0x69, 0x02, 0xa9, 0x80, 0x03, 0x50, 0x8f, 0x31, 0x0d, 0xbf, 0xa6, 0xec, 0xca,
+	0xb0, 0x2d, 0x29, 0xb6, 0xf3, 0x1f, 0xce, 0x76, 0x5d, 0x7a, 0xce, 0xab, 0xc3, 0xdf, 0x7c, 0x4e,
+	0xd9, 0x95, 0xc2, 0xbc, 0x2d, 0xbd, 0x8f, 0x34, 0xfb, 0x34, 0xb2, 0x8f, 0x9c, 0x18, 0xd3, 0x91,
+	0x1b, 0xfc, 0x1d, 0x70, 0x47, 0x0e, 0xbc, 0xdb, 0xe9, 0x50, 0x26, 0x4c, 0x23, 0x3d, 0xbb, 0x2e,
+	0xbd, 0xba, 0x81, 0x3c, 0xd7, 0x96, 0xdb, 0xd2, 0xfb, 0xd1, 0x0c, 0xa8, 0x89, 0xf1, 0x51, 0xdd,
+	0xc0, 0x1a, 0x57, 0xc8, 0x81, 0x43, 0xd2, 0xce, 0xde, 0xc1, 0x27, 0x26, 0x23, 0x4b, 0x65, 0x74,
+	0x36, 0x57, 0x46, 0xb5, 0xe3, 0x93, 0xb3, 0xbd, 0x83, 0x4f, 0x86, 0x09, 0x99, 0xb6, 0x99, 0x84,
+	0xf5, 0x51, 0x4d, 0x8b, 0x3a, 0x9b, 0x13, 0x60, 0xc4, 0xf0, 0x12, 0xf3, 0x4b, 0xd5, 0x94, 0xd5,
+	0x60, 0xfb, 0xba, 0xf4, 0x80, 0x46, 0xfa, 0x12, 0xf3, 0xcb, 0xf1, 0xb9, 0xb4, 0x07, 0x7f, 0xc4,
+	0x85, 0x48, 0xbb, 0xf9, 0x10, 0x0b, 0xe8, 0x60, 0xe9, 0x35, 0xda, 0xff, 0x81, 0xd9, 0xff, 0xca,
+	0x83, 0xf7, 0x7f, 0x70, 0xdf, 0xfe, 0x0f, 0xa6, 0xf7, 0xaf, 0x7d, 0x46, 0xa4, 0x2f, 0x0c, 0xe9,
+	0xea, 0x83, 0x49, 0x5f, 0xdc, 0x47, 0xfa, 0x62, 0x9a, 0x54, 0xfb, 0xc8, 0x66, 0x9f, 0xa9, 0x44,
+	0xcb, 0x7e, 0x78, 0xb3, 0xdf, 0x29, 0x6a, 0x7d, 0xa4, 0xd1, 0x74, 0x7f, 0x02, 0x1b, 0x11, 0x2d,
+	0xb8, 0x90, 0xba, 0x82, 0x76, 0x32, 0x62, 0x38, 0xab, 0x8a, 0xf3, 0x64, 0x2e, 0xce, 0xa7, 0xe6,
+	0x22, 0xb9, 0x07, 0xcf, 0x47, 0xcd, 0x69, 0xb5, 0x66, 0xef, 0x00, 0xb7, 0x43, 0x04, 0x61, 0xbc,
+	0xdd, 0x65, 0x89, 0x61, 0x06, 0x8a, 0xf9, 0x78, 0x2e, 0x66, 0xf3, 0x1c, 0xcc, 0x62, 0xf9, 0xa8,
+	0x31, 0x56, 0x69, 0xc6, 0x6f, 0x40, 0x3d, 0x95, 0xdb, 0x68, 0x77, 0x33, 0xc3, 0x57, 0x53, 0x7c,
+	0x47, 0x73, 0xf1, 0x99, 0x87, 0x79, 0x1a, 0xc9, 0x47, 0x6b, 0x43, 0x85, 0xe6, 0xea, 0x02, 0x98,
+	0x77, 0x53, 0x16, 0x26, 0x19, 0x8e, 0x52, 0xc2, 0x0c, 0x9f, 0xa3, 0xf8, 0xbe, 0x98, 0x8b, 0xef,
+	0xb1, 0xe6, 0xbb, 0x8b, 0xe6, 0x23, 0x57, 0x2a, 0xbf, 0xd0, 0x3a, 0x4d, 0x1b, 0x03, 0xa7, 0x4d,
+	0x58, 0x96, 0x16, 0x86, 0x70, 0x4d, 0x11, 0x1e, 0xce, 0x45, 0x68, 0xfa, 0x74, 0x12, 0xc7, 0x47,
+	0x35, 0x2d, 0x8e, 0x58, 0x32, 0x5a, 0xc4, 0x74, 0xc8, 0xb2, 0xfe, 0x70, 0x96, 0x49, 0x1c, 0x1f,
+	0xd5, 0xb4, 0xa8, 0x59, 0xfa, 0xa0, 0x89, 0x19, 0xa3, 0xef, 0x66, 0x6a, 0x08, 0x15, 0xd9, 0x97,
+	0x73, 0x91, 0x3d, 0xd1, 0x64, 0xf7, 0xc0, 0xf9, 0x68, 0x5d, 0x69, 0xa7, 0xaa, 0x48, 0x81, 0x9b,
+	0x13, 0x96, 0x90, 0xc9, 0x39, 0xd0, 0x7c, 0x78, 0x6b, 0xce, 0x62, 0xf9, 0xa8, 0xae, 0x54, 0xa3,
+	0xbb, 0xff, 0xd4, 0xb2, 0xeb, 0x6e, 0xe3, 0xd4, 0xb2, 0x1b, 0xae, 0x7b, 0x6a, 0xd9, 0xae, 0xbb,
+	0x8e, 0xd6, 0x06, 0x34, 0xa3, 0x61, 0xef, 0x53, 0x1d, 0x81, 0x6a, 0xe4, 0x1d, 0xe6, 0xe6, 0x41,
+	0x46, 0xf5, 0x08, 0x0b, 0x9c, 0x0d, 0xb8, 0x30, 0x70, 0xbb, 0x60, 0xf9, 0x5c, 0xc8, 0xd7, 0x10,
+	0x17, 0x54, 0xae, 0xc8, 0x40, 0x0f, 0x48, 0x24, 0x97, 0x70, 0x03, 0x2c, 0xf7, 0x70, 0xd6, 0xd5,
+	0xef, 0x33, 0x55, 0xa4, 0x05, 0xff, 0x0c, 0x34, 0x2e, 0x18, 0x2e, 0x38, 0x8e, 0x44, 0x4a, 0x8b,
+	0xd7, 0x34, 0xe1, 0x10, 0x02, 0x4b, 0x5d, 0xd4, 0x3a, 0x56, 0xad, 0xe1, 0x2f, 0x80, 0x95, 0xd1,
+	0x84, 0xb7, 0x96, 0xd4, 0xac, 0xff, 0xe8, 0xee, 0xac, 0x7f, 0x4d, 0x13, 0xa4, 0x5c, 0xfc, 0x7f,
+	0x2e, 0x81, 0xca, 0x6b, 0x9a, 0xc0, 0x16, 0x58, 0xc5, 0x71, 0xcc, 0x08, 0xe7, 0x06, 0x69, 0x28,
+	0xc2, 0x47, 0x60, 0x45, 0xd0, 0x4e, 0x1a, 0x69, 0xb8, 0x2a, 0x32, 0x92, 0x24, 0x8e, 0xb1, 0xc0,
+	0x6a, 0xd4, 0x39, 0x48, 0xad, 0xe1, 0x3e, 0x70, 0x54, 0x66, 0x61, 0xd1, 0xcd, 0xdb, 0x84, 0xa9,
+	0x89, 0x65, 0x05, 0x8d, 0x9b, 0xd2, 0xab, 0x29, 0xfd, 0x5b, 0xa5, 0x46, 0x93, 0x02, 0xfc, 0x18,
+	0xac, 0x8a, 0xfe, 0xe4, 0xb0, 0x69, 0xde, 0x94, 0x5e, 0x43, 0x8c, 0xd3, 0x94, 0xb3, 0x04, 0xad,
+	0x88, 0xbe, 0x9a, 0x29, 0xbb, 0xc0, 0x16, 0xfd, 0x30, 0x2d, 0x62, 0xd2, 0x57, 0xf3, 0xc4, 0x0a,
+	0x36, 0x6e, 0x4a, 0xcf, 0x9d, 0x70, 0x3f, 0x91, 0x36, 0xb4, 0x2a, 0xfa, 0x6a, 0x01, 0x3f, 0x06,
+	0x40, 0x6f, 0x49, 0x31, 0xe8, 0x69, 0xb0, 0x76, 0x53, 0x7a, 0x55, 0xa5, 0x55, 0xd8, 0xe3, 0x25,
+	0xf4, 0xc1, 0xb2, 0xc6, 0xb6, 0x15, 0xb6, 0x73, 0x53, 0x7a, 0x76, 0x46, 0x13, 0x8d, 0xa9, 0x4d,
+	0xb2, 0x54, 0x8c, 0xe4, 0xb4, 0x47, 0x62, 0x75, 0xe1, 0xda, 0x68, 0x28, 0xfa, 0x7f, 0x59, 0x02,
+	0xf6, 0x45, 0x1f, 0x11, 0xde, 0xcd, 0x04, 0xfc, 0x1c, 0xb8, 0x11, 0x2d, 0x04, 0xc3, 0x91, 0x08,
+	0xa7, 0x4a, 0x1b, 0x3c, 0x1d, 0x77, 0xd8, 0xac, 0x87, 0x8f, 0x1a, 0x43, 0xd5, 0xa1, 0xa9, 0xff,
+	0x06, 0x58, 0x6e, 0x67, 0x94, 0xe6, 0xaa, 0x13, 0x1c, 0xa4, 0x05, 0x88, 0x54, 0xd5, 0xd4, 0x29,
+	0x57, 0xd4, 0x7b, 0xe3, 0x4f, 0xee, 0x9e, 0xf2, 0x4c, 0xab, 0x04, 0x8f, 0xcc, 0xbb, 0x63, 0x5d,
+	0x73, 0x9b, 0x78, 0x5f, 0xd6, 0x56, 0xb5, 0x92, 0x0b, 0x2a, 0x8c, 0x08, 0x75, 0x68, 0x0e, 0x92,
+	0x4b, 0xf8, 0x04, 0xd8, 0x8c, 0xf4, 0x08, 0x13, 0x24, 0x56, 0x87, 0x63, 0xa3, 0x91, 0x0c, 0x1f,
+	0x03, 0x3b, 0xc1, 0x3c, 0xec, 0x72, 0x12, 0xeb, 0x93, 0x40, 0xab, 0x09, 0xe6, 0x5f, 0x71, 0x12,
+	0x7f, 0x66, 0xfd, 0xf9, 0x6f, 0xde, 0x82, 0x8f, 0x41, 0xed, 0x30, 0x8a, 0x08, 0xe7, 0x17, 0xdd,
+	0x4e, 0x46, 0xfe, 0x47, 0x87, 0xed, 0x03, 0x87, 0x0b, 0xca, 0x70, 0x42, 0xc2, 0x2b, 0x32, 0x30,
+	0x7d, 0xa6, 0xbb, 0xc6, 0xe8, 0x7f, 0x4d, 0x06, 0x1c, 0x4d, 0x0a, 0x86, 0xe2, 0xfb, 0x0a, 0xa8,
+	0x5d, 0x30, 0x1c, 0x11, 0xf3, 0xd2, 0x29, 0x7b, 0x55, 0x8a, 0xcc, 0x50, 0x18, 0x49, 0x72, 0x8b,
+	0x34, 0x27, 0xb4, 0x2b, 0xcc, 0xf3, 0x34, 0x14, 0x65, 0x04, 0x23, 0xa4, 0x4f, 0x22, 0x55, 0x46,
+	0x0b, 0x19, 0x09, 0x1e, 0x80, 0xb5, 0x38, 0xe5, 0xea, 0xe5, 0x9f, 0x0b, 0x1c, 0x5d, 0xe9, 0xf4,
+	0x03, 0xf7, 0xa6, 0xf4, 0x1c, 0x63, 0x38, 0x97, 0x7a, 0x34, 0x25, 0xc1, 0x97, 0xa0, 0x31, 0x0e,
+	0x53, 0xbb, 0x55, 0xb5, 0xb1, 0x03, 0x78, 0x53, 0x7a, 0xf5, 0x91, 0xab, 0xb2, 0xa0, 0x19, 0x59,
+	0x9e, 0x74, 0x4c, 0xda, 0xdd, 0x44, 0x35, 0x9f, 0x8d, 0xb4, 0x20, 0xb5, 0x59, 0x9a, 0xa7, 0x42,
+	0x35, 0xdb, 0x32, 0xd2, 0x02, 0x7c, 0x09, 0xaa, 0xb4, 0x47, 0x18, 0x4b, 0x63, 0xc2, 0xd5, 0xf4,
+	0xfd, 0x7f, 0x5f, 0x0e, 0x68, 0xec, 0x2f, 0x93, 0x33, 0x1f, 0x36, 0x39, 0xc9, 0x29, 0x1b, 0xa8,
+	0x71, 0x6a, 0x92, 0xd3, 0x86, 0x37, 0x4a, 0x8f, 0xa6, 0x24, 0x18, 0x00, 0x68, 0xc2, 0x18, 0x11,
+	0x5d, 0x56, 0x84, 0xea, 0xf9, 0x77, 0x54, 0xac, 0x7a, 0x0a, 0xb5, 0x15, 0x29, 0xe3, 0x2b, 0x2c,
+	0x30, 0xba, 0xa3, 0x39, 0xb5, 0x6c, 0xcb, 0x5d, 0x3e, 0xb5, 0xec, 0x55, 0xd7, 0x1e, 0xe5, 0x6f,
+	0x76, 0x81, 0x9a, 0x43, 0x79, 0x02, 0xde, 0xff, 0xcf, 0x22, 0x70, 0x67, 0x3f, 0x40, 0xe0, 0x16,
+	0x70, 0x72, 0x9e, 0x84, 0xf2, 0xca, 0x0e, 0xbb, 0x2c, 0x33, 0xa7, 0x0d, 0x72, 0x9e, 0x5c, 0x0c,
+	0x3a, 0xe4, 0x2b, 0x96, 0xc1, 0x67, 0xa0, 0x29, 0x3d, 0xd4, 0xb5, 0xa9, 0xfd, 0x0a, 0x9c, 0x0f,
+	0x6f, 0x53, 0x37, 0xe7, 0xc9, 0x6f, 0xa5, 0x45, 0x7a, 0xbf, 0xc5, 0x39, 0x81, 0xa7, 0xa0, 0x36,
+	0x76, 0x95, 0x8f, 0x94, 0xbc, 0x38, 0x7f, 0xfa, 0xa1, 0x8f, 0xa4, 0x37, 0x3c, 0x39, 0x14, 0x82,
+	0xc9, 0xe8, 0xc0, 0x92, 0x0f, 0x15, 0x02, 0xbd, 0x21, 0x1c, 0x87, 0x6f, 0x81, 0x53, 0xc8, 0x4f,
+	0x93, 0xd8, 0x80, 0x59, 0x0a, 0xec, 0x67, 0x1f, 0x02, 0x7b, 0xab, 0x7c, 0xdf, 0xe8, 0xad, 0x1b,
+	0xb8, 0x9a, 0x06, 0x50, 0x78, 0xfe, 0x37, 0xa0, 0x79, 0x8f, 0xa7, 0xbc, 0x7f, 0x55, 0x4a, 0xe6,
+	0xe2, 0x97, 0x6b, 0xf8, 0x2b, 0xb0, 0x8c, 0x85, 0x60, 0xc3, 0x9b, 0x7f, 0x8e, 0x04, 0x74, 0x9c,
+	0xff, 0x12, 0xac, 0xdf, 0xf1, 0xb8, 0x97, 0x09, 0x02, 0x4b, 0x66, 0x67, 0x0a, 0xaa, 0xd6, 0x41,
+	0xf0, 0xed, 0xf5, 0xe6, 0xe2, 0x77, 0xd7, 0x9b, 0x8b, 0xdf, 0x5f, 0x6f, 0x2e, 0xfe, 0xf5, 0xfd,
+	0xe6, 0xc2, 0x77, 0xef, 0x37, 0x17, 0xfe, 0xf5, 0x7e, 0x73, 0xe1, 0xf7, 0xdb, 0x13, 0x93, 0x57,
+	0x5c, 0x62, 0xc6, 0x53, 0xbe, 0x3b, 0xfe, 0xeb, 0xa0, 0xaf, 0xfe, 0x3c, 0x50, 0xc5, 0x6a, 0xaf,
+	0xa8, 0x3f, 0x05, 0x3e, 0xfd, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe8, 0xff, 0x38, 0xa9, 0x5a,
+	0x10, 0x00, 0x00,
+}
+
+func (m *Params) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Params) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.EIP712AllowedMsgs) > 0 {
+		for iNdEx := len(m.EIP712AllowedMsgs) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.EIP712AllowedMsgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintEvm(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x32
+		}
+	}
+	{
+		size, err := m.ChainConfig.MarshalToSizedBuffer(dAtA[:i])
+		if err != nil {
+			return 0, err
+		}
+		i -= size
+		i = encodeVarintEvm(dAtA, i, uint64(size))
+	}
+	i--
+	dAtA[i] = 0x2a
+	if len(m.ExtraEIPs) > 0 {
+		dAtA3 := make([]byte, len(m.ExtraEIPs)*10)
+		var j2 int
+		for _, num1 := range m.ExtraEIPs {
+			num := uint64(num1)
+			for num >= 1<<7 {
+				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j2++
+			}
+			dAtA3[j2] = uint8(num)
+			j2++
+		}
+		i -= j2
+		copy(dAtA[i:], dAtA3[:j2])
+		i = encodeVarintEvm(dAtA, i, uint64(j2))
+		i--
+		dAtA[i] = 0x22
+	}
+	if m.EnableCall {
+		i--
+		if m.EnableCall {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x18
+	}
+	if m.EnableCreate {
+		i--
+		if m.EnableCreate {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x10
+	}
+	if len(m.EvmDenom) > 0 {
+		i -= len(m.EvmDenom)
+		copy(dAtA[i:], m.EvmDenom)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.EvmDenom)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *ChainConfig) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *ChainConfig) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ChainConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.MergeForkBlock != nil {
+		{
+			size := m.MergeForkBlock.Size()
+			i -= size
+			if _, err := m.MergeForkBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x9a
+	}
+	if m.ArrowGlacierBlock != nil {
+		{
+			size := m.ArrowGlacierBlock.Size()
+			i -= size
+			if _, err := m.ArrowGlacierBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x92
+	}
+	if m.LondonBlock != nil {
+		{
+			size := m.LondonBlock.Size()
+			i -= size
+			if _, err := m.LondonBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x8a
+	}
+	if m.BerlinBlock != nil {
+		{
+			size := m.BerlinBlock.Size()
+			i -= size
+			if _, err := m.BerlinBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x6a
+	}
+	if m.MuirGlacierBlock != nil {
+		{
+			size := m.MuirGlacierBlock.Size()
+			i -= size
+			if _, err := m.MuirGlacierBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x62
+	}
+	if m.IstanbulBlock != nil {
+		{
+			size := m.IstanbulBlock.Size()
+			i -= size
+			if _, err := m.IstanbulBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x5a
+	}
+	if m.PetersburgBlock != nil {
+		{
+			size := m.PetersburgBlock.Size()
+			i -= size
+			if _, err := m.PetersburgBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x52
+	}
+	if m.ConstantinopleBlock != nil {
+		{
+			size := m.ConstantinopleBlock.Size()
+			i -= size
+			if _, err := m.ConstantinopleBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x4a
+	}
+	if m.ByzantiumBlock != nil {
+		{
+			size := m.ByzantiumBlock.Size()
+			i -= size
+			if _, err := m.ByzantiumBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x42
+	}
+	if m.EIP158Block != nil {
+		{
+			size := m.EIP158Block.Size()
+			i -= size
+			if _, err := m.EIP158Block.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x3a
+	}
+	if m.EIP155Block != nil {
+		{
+			size := m.EIP155Block.Size()
+			i -= size
+			if _, err := m.EIP155Block.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x32
+	}
+	if len(m.EIP150Hash) > 0 {
+		i -= len(m.EIP150Hash)
+		copy(dAtA[i:], m.EIP150Hash)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.EIP150Hash)))
+		i--
+		dAtA[i] = 0x2a
+	}
+	if m.EIP150Block != nil {
+		{
+			size := m.EIP150Block.Size()
+			i -= size
+			if _, err := m.EIP150Block.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x22
+	}
+	if m.DAOForkSupport {
+		i--
+		if m.DAOForkSupport {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x18
+	}
+	if m.DAOForkBlock != nil {
+		{
+			size := m.DAOForkBlock.Size()
+			i -= size
+			if _, err := m.DAOForkBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
+	}
+	if m.HomesteadBlock != nil {
+		{
+			size := m.HomesteadBlock.Size()
+			i -= size
+			if _, err := m.HomesteadBlock.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *State) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *State) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *State) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.Value) > 0 {
+		i -= len(m.Value)
+		copy(dAtA[i:], m.Value)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Value)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.Key) > 0 {
+		i -= len(m.Key)
+		copy(dAtA[i:], m.Key)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Key)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *TransactionLogs) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *TransactionLogs) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *TransactionLogs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.Logs) > 0 {
+		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Logs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintEvm(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if len(m.Hash) > 0 {
+		i -= len(m.Hash)
+		copy(dAtA[i:], m.Hash)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Hash)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *Log) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Log) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Log) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.Removed {
+		i--
+		if m.Removed {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x48
+	}
+	if m.Index != 0 {
+		i = encodeVarintEvm(dAtA, i, uint64(m.Index))
+		i--
+		dAtA[i] = 0x40
+	}
+	if len(m.BlockHash) > 0 {
+		i -= len(m.BlockHash)
+		copy(dAtA[i:], m.BlockHash)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.BlockHash)))
+		i--
+		dAtA[i] = 0x3a
+	}
+	if m.TxIndex != 0 {
+		i = encodeVarintEvm(dAtA, i, uint64(m.TxIndex))
+		i--
+		dAtA[i] = 0x30
+	}
+	if len(m.TxHash) > 0 {
+		i -= len(m.TxHash)
+		copy(dAtA[i:], m.TxHash)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.TxHash)))
+		i--
+		dAtA[i] = 0x2a
+	}
+	if m.BlockNumber != 0 {
+		i = encodeVarintEvm(dAtA, i, uint64(m.BlockNumber))
+		i--
+		dAtA[i] = 0x20
+	}
+	if len(m.Data) > 0 {
+		i -= len(m.Data)
+		copy(dAtA[i:], m.Data)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Data)))
+		i--
+		dAtA[i] = 0x1a
+	}
+	if len(m.Topics) > 0 {
+		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.Topics[iNdEx])
+			copy(dAtA[i:], m.Topics[iNdEx])
+			i = encodeVarintEvm(dAtA, i, uint64(len(m.Topics[iNdEx])))
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if len(m.Address) > 0 {
+		i -= len(m.Address)
+		copy(dAtA[i:], m.Address)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Address)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *TxResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *TxResult) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *TxResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.GasUsed != 0 {
+		i = encodeVarintEvm(dAtA, i, uint64(m.GasUsed))
+		i--
+		dAtA[i] = 0x30
+	}
+	if m.Reverted {
+		i--
+		if m.Reverted {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x28
+	}
+	if len(m.Ret) > 0 {
+		i -= len(m.Ret)
+		copy(dAtA[i:], m.Ret)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Ret)))
+		i--
+		dAtA[i] = 0x22
+	}
+	{
+		size, err := m.TxLogs.MarshalToSizedBuffer(dAtA[:i])
+		if err != nil {
+			return 0, err
+		}
+		i -= size
+		i = encodeVarintEvm(dAtA, i, uint64(size))
+	}
+	i--
+	dAtA[i] = 0x1a
+	if len(m.Bloom) > 0 {
+		i -= len(m.Bloom)
+		copy(dAtA[i:], m.Bloom)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Bloom)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.ContractAddress) > 0 {
+		i -= len(m.ContractAddress)
+		copy(dAtA[i:], m.ContractAddress)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.ContractAddress)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *AccessTuple) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *AccessTuple) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *AccessTuple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.StorageKeys) > 0 {
+		for iNdEx := len(m.StorageKeys) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.StorageKeys[iNdEx])
+			copy(dAtA[i:], m.StorageKeys[iNdEx])
+			i = encodeVarintEvm(dAtA, i, uint64(len(m.StorageKeys[iNdEx])))
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if len(m.Address) > 0 {
+		i -= len(m.Address)
+		copy(dAtA[i:], m.Address)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Address)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *TraceConfig) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *TraceConfig) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *TraceConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.EnableReturnData {
+		i--
+		if m.EnableReturnData {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x60
+	}
+	if m.EnableMemory {
+		i--
+		if m.EnableMemory {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x58
+	}
+	if m.Overrides != nil {
+		{
+			size, err := m.Overrides.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintEvm(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x52
+	}
+	if m.Limit != 0 {
+		i = encodeVarintEvm(dAtA, i, uint64(m.Limit))
+		i--
+		dAtA[i] = 0x48
+	}
+	if m.Debug {
+		i--
+		if m.Debug {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x40
+	}
+	if m.DisableStorage {
+		i--
+		if m.DisableStorage {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x30
+	}
+	if m.DisableStack {
+		i--
+		if m.DisableStack {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x28
+	}
+	if m.Reexec != 0 {
+		i = encodeVarintEvm(dAtA, i, uint64(m.Reexec))
+		i--
+		dAtA[i] = 0x18
+	}
+	if len(m.Timeout) > 0 {
+		i -= len(m.Timeout)
+		copy(dAtA[i:], m.Timeout)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Timeout)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.Tracer) > 0 {
+		i -= len(m.Tracer)
+		copy(dAtA[i:], m.Tracer)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Tracer)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *EIP712AllowedMsg) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *EIP712AllowedMsg) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *EIP712AllowedMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.NestedTypes) > 0 {
+		for iNdEx := len(m.NestedTypes) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.NestedTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintEvm(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x22
+		}
+	}
+	if len(m.ValueTypes) > 0 {
+		for iNdEx := len(m.ValueTypes) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.ValueTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintEvm(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x1a
+		}
+	}
+	if len(m.MsgValueTypeName) > 0 {
+		i -= len(m.MsgValueTypeName)
+		copy(dAtA[i:], m.MsgValueTypeName)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.MsgValueTypeName)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.MsgTypeUrl) > 0 {
+		i -= len(m.MsgTypeUrl)
+		copy(dAtA[i:], m.MsgTypeUrl)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.MsgTypeUrl)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *EIP712NestedMsgType) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *EIP712NestedMsgType) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *EIP712NestedMsgType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.Attrs) > 0 {
+		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Attrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintEvm(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Name)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *EIP712MsgAttrType) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *EIP712MsgAttrType) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *EIP712MsgAttrType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.Type) > 0 {
+		i -= len(m.Type)
+		copy(dAtA[i:], m.Type)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Type)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Name)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func encodeVarintEvm(dAtA []byte, offset int, v uint64) int {
+	offset -= sovEvm(v)
+	base := offset
+	for v >= 1<<7 {
+		dAtA[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	dAtA[offset] = uint8(v)
+	return base
+}
+func (m *Params) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.EvmDenom)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.EnableCreate {
+		n += 2
+	}
+	if m.EnableCall {
+		n += 2
+	}
+	if len(m.ExtraEIPs) > 0 {
+		l = 0
+		for _, e := range m.ExtraEIPs {
+			l += sovEvm(uint64(e))
+		}
+		n += 1 + sovEvm(uint64(l)) + l
+	}
+	l = m.ChainConfig.Size()
+	n += 1 + l + sovEvm(uint64(l))
+	if len(m.EIP712AllowedMsgs) > 0 {
+		for _, e := range m.EIP712AllowedMsgs {
+			l = e.Size()
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
+	return n
+}
+
+func (m *ChainConfig) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.HomesteadBlock != nil {
+		l = m.HomesteadBlock.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.DAOForkBlock != nil {
+		l = m.DAOForkBlock.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.DAOForkSupport {
+		n += 2
+	}
+	if m.EIP150Block != nil {
+		l = m.EIP150Block.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	l = len(m.EIP150Hash)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.EIP155Block != nil {
+		l = m.EIP155Block.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.EIP158Block != nil {
+		l = m.EIP158Block.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.ByzantiumBlock != nil {
+		l = m.ByzantiumBlock.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.ConstantinopleBlock != nil {
+		l = m.ConstantinopleBlock.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.PetersburgBlock != nil {
+		l = m.PetersburgBlock.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.IstanbulBlock != nil {
+		l = m.IstanbulBlock.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.MuirGlacierBlock != nil {
+		l = m.MuirGlacierBlock.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.BerlinBlock != nil {
+		l = m.BerlinBlock.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.LondonBlock != nil {
+		l = m.LondonBlock.Size()
+		n += 2 + l + sovEvm(uint64(l))
+	}
+	if m.ArrowGlacierBlock != nil {
+		l = m.ArrowGlacierBlock.Size()
+		n += 2 + l + sovEvm(uint64(l))
+	}
+	if m.MergeForkBlock != nil {
+		l = m.MergeForkBlock.Size()
+		n += 2 + l + sovEvm(uint64(l))
+	}
+	return n
+}
+
+func (m *State) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Key)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	l = len(m.Value)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	return n
+}
+
+func (m *TransactionLogs) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Hash)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if len(m.Logs) > 0 {
+		for _, e := range m.Logs {
+			l = e.Size()
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
+	return n
+}
+
+func (m *Log) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Address)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if len(m.Topics) > 0 {
+		for _, s := range m.Topics {
+			l = len(s)
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
+	l = len(m.Data)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.BlockNumber != 0 {
+		n += 1 + sovEvm(uint64(m.BlockNumber))
+	}
+	l = len(m.TxHash)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.TxIndex != 0 {
+		n += 1 + sovEvm(uint64(m.TxIndex))
+	}
+	l = len(m.BlockHash)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.Index != 0 {
+		n += 1 + sovEvm(uint64(m.Index))
+	}
+	if m.Removed {
+		n += 2
+	}
+	return n
+}
+
+func (m *TxResult) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.ContractAddress)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	l = len(m.Bloom)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	l = m.TxLogs.Size()
+	n += 1 + l + sovEvm(uint64(l))
+	l = len(m.Ret)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.Reverted {
+		n += 2
+	}
+	if m.GasUsed != 0 {
+		n += 1 + sovEvm(uint64(m.GasUsed))
+	}
+	return n
+}
+
+func (m *AccessTuple) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Address)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if len(m.StorageKeys) > 0 {
+		for _, s := range m.StorageKeys {
+			l = len(s)
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
+	return n
+}
+
+func (m *TraceConfig) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Tracer)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	l = len(m.Timeout)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.Reexec != 0 {
+		n += 1 + sovEvm(uint64(m.Reexec))
+	}
+	if m.DisableStack {
+		n += 2
+	}
+	if m.DisableStorage {
+		n += 2
+	}
+	if m.Debug {
+		n += 2
+	}
+	if m.Limit != 0 {
+		n += 1 + sovEvm(uint64(m.Limit))
+	}
+	if m.Overrides != nil {
+		l = m.Overrides.Size()
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if m.EnableMemory {
+		n += 2
+	}
+	if m.EnableReturnData {
+		n += 2
+	}
+	return n
+}
+
+func (m *EIP712AllowedMsg) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.MsgTypeUrl)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	l = len(m.MsgValueTypeName)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if len(m.ValueTypes) > 0 {
+		for _, e := range m.ValueTypes {
+			l = e.Size()
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
+	if len(m.NestedTypes) > 0 {
+		for _, e := range m.NestedTypes {
+			l = e.Size()
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
+	return n
+}
+
+func (m *EIP712NestedMsgType) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if len(m.Attrs) > 0 {
+		for _, e := range m.Attrs {
+			l = e.Size()
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
+	return n
+}
+
+func (m *EIP712MsgAttrType) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	l = len(m.Type)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	return n
+}
+
+func sovEvm(x uint64) (n int) {
+	return (math_bits.Len64(x|1) + 6) / 7
+}
+func sozEvm(x uint64) (n int) {
+	return sovEvm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *Params) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Params: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EvmDenom", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.EvmDenom = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EnableCreate", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.EnableCreate = bool(v != 0)
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EnableCall", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.EnableCall = bool(v != 0)
+		case 4:
+			if wireType == 0 {
+				var v int64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowEvm
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					v |= int64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				m.ExtraEIPs = append(m.ExtraEIPs, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowEvm
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= int(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthEvm
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex < 0 {
+					return ErrInvalidLengthEvm
+				}
+				if postIndex > l {
+					return io.ErrUnexpectedEOF
+				}
+				var elementCount int
+				var count int
+				for _, integer := range dAtA[iNdEx:postIndex] {
+					if integer < 128 {
+						count++
+					}
+				}
+				elementCount = count
+				if elementCount != 0 && len(m.ExtraEIPs) == 0 {
+					m.ExtraEIPs = make([]int64, 0, elementCount)
+				}
+				for iNdEx < postIndex {
+					var v int64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowEvm
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						v |= int64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					m.ExtraEIPs = append(m.ExtraEIPs, v)
+				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field ExtraEIPs", wireType)
+			}
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ChainConfig", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.ChainConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EIP712AllowedMsgs", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.EIP712AllowedMsgs = append(m.EIP712AllowedMsgs, EIP712AllowedMsg{})
+			if err := m.EIP712AllowedMsgs[len(m.EIP712AllowedMsgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *ChainConfig) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ChainConfig: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ChainConfig: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HomesteadBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.HomesteadBlock = &v
+			if err := m.HomesteadBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DAOForkBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.DAOForkBlock = &v
+			if err := m.DAOForkBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DAOForkSupport", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.DAOForkSupport = bool(v != 0)
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EIP150Block", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.EIP150Block = &v
+			if err := m.EIP150Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EIP150Hash", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.EIP150Hash = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EIP155Block", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.EIP155Block = &v
+			if err := m.EIP155Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EIP158Block", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.EIP158Block = &v
+			if err := m.EIP158Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 8:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ByzantiumBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.ByzantiumBlock = &v
+			if err := m.ByzantiumBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 9:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConstantinopleBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.ConstantinopleBlock = &v
+			if err := m.ConstantinopleBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 10:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field PetersburgBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.PetersburgBlock = &v
+			if err := m.PetersburgBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 11:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field IstanbulBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.IstanbulBlock = &v
+			if err := m.IstanbulBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 12:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MuirGlacierBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.MuirGlacierBlock = &v
+			if err := m.MuirGlacierBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 13:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field BerlinBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.BerlinBlock = &v
+			if err := m.BerlinBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 17:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field LondonBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.LondonBlock = &v
+			if err := m.LondonBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 18:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ArrowGlacierBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.ArrowGlacierBlock = &v
+			if err := m.ArrowGlacierBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 19:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MergeForkBlock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			var v github_com_cosmos_cosmos_sdk_types.Int
+			m.MergeForkBlock = &v
+			if err := m.MergeForkBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *State) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: State: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Key = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Value = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *TransactionLogs) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TransactionLogs: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TransactionLogs: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Hash = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Logs = append(m.Logs, &Log{})
+			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Log) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Log: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Address = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Topics = append(m.Topics, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
+			if m.Data == nil {
+				m.Data = []byte{}
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
+			}
+			m.BlockNumber = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.BlockNumber |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.TxHash = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 6:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TxIndex", wireType)
+			}
+			m.TxIndex = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.TxIndex |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.BlockHash = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 8:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
+			}
+			m.Index = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Index |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 9:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Removed = bool(v != 0)
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *TxResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TxResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TxResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ContractAddress = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Bloom", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Bloom = append(m.Bloom[:0], dAtA[iNdEx:postIndex]...)
+			if m.Bloom == nil {
+				m.Bloom = []byte{}
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TxLogs", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.TxLogs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Ret", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Ret = append(m.Ret[:0], dAtA[iNdEx:postIndex]...)
+			if m.Ret == nil {
+				m.Ret = []byte{}
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Reverted", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Reverted = bool(v != 0)
+		case 6:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
+			}
+			m.GasUsed = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.GasUsed |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *AccessTuple) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: AccessTuple: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: AccessTuple: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Address = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field StorageKeys", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.StorageKeys = append(m.StorageKeys, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *TraceConfig) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TraceConfig: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TraceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tracer", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Tracer = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Timeout = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Reexec", wireType)
+			}
+			m.Reexec = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Reexec |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DisableStack", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.DisableStack = bool(v != 0)
+		case 6:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DisableStorage", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.DisableStorage = bool(v != 0)
+		case 8:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Debug = bool(v != 0)
+		case 9:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
+			}
+			m.Limit = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Limit |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 10:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Overrides", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Overrides == nil {
+				m.Overrides = &ChainConfig{}
+			}
+			if err := m.Overrides.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 11:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EnableMemory", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.EnableMemory = bool(v != 0)
+		case 12:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EnableReturnData", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.EnableReturnData = bool(v != 0)
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *EIP712AllowedMsg) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: EIP712AllowedMsg: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: EIP712AllowedMsg: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MsgTypeUrl", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.MsgTypeUrl = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MsgValueTypeName", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.MsgValueTypeName = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ValueTypes", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ValueTypes = append(m.ValueTypes, EIP712MsgAttrType{})
+			if err := m.ValueTypes[len(m.ValueTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field NestedTypes", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.NestedTypes = append(m.NestedTypes, EIP712NestedMsgType{})
+			if err := m.NestedTypes[len(m.NestedTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *EIP712NestedMsgType) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: EIP712NestedMsgType: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: EIP712NestedMsgType: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Attrs = append(m.Attrs, EIP712MsgAttrType{})
+			if err := m.Attrs[len(m.Attrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *EIP712MsgAttrType) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: EIP712MsgAttrType: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: EIP712MsgAttrType: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Type = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func skipEvm(dAtA []byte) (n int, err error) {
+	l := len(dAtA)
+	iNdEx := 0
+	depth := 0
+	for iNdEx < l {
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return 0, ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return 0, io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		wireType := int(wire & 0x7)
+		switch wireType {
+		case 0:
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return 0, ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return 0, io.ErrUnexpectedEOF
+				}
+				iNdEx++
+				if dAtA[iNdEx-1] < 0x80 {
+					break
+				}
+			}
+		case 1:
+			iNdEx += 8
+		case 2:
+			var length int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return 0, ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return 0, io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				length |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if length < 0 {
+				return 0, ErrInvalidLengthEvm
+			}
+			iNdEx += length
+		case 3:
+			depth++
+		case 4:
+			if depth == 0 {
+				return 0, ErrUnexpectedEndOfGroupEvm
+			}
+			depth--
+		case 5:
+			iNdEx += 4
+		default:
+			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
+		}
+		if iNdEx < 0 {
+			return 0, ErrInvalidLengthEvm
+		}
+		if depth == 0 {
+			return iNdEx, nil
+		}
+	}
+	return 0, io.ErrUnexpectedEOF
+}
+
+var (
+	ErrInvalidLengthEvm        = fmt.Errorf("proto: negative length found during unmarshaling")
+	ErrIntOverflowEvm          = fmt.Errorf("proto: integer overflow")
+	ErrUnexpectedEndOfGroupEvm = fmt.Errorf("proto: unexpected end of group")
+)
diff --git a/x/evm/migrations/v2/types/params.go b/x/evm/migrations/v2/types/params.go
new file mode 100644
index 00000000..03bc8a17
--- /dev/null
+++ b/x/evm/migrations/v2/types/params.go
@@ -0,0 +1,178 @@
+package types
+
+import (
+	"fmt"
+	"math/big"
+
+	"github.com/ethereum/go-ethereum/params"
+
+	sdk "github.com/cosmos/cosmos-sdk/types"
+	paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
+	"github.com/ethereum/go-ethereum/core/vm"
+	"github.com/tharsis/ethermint/types"
+)
+
+var _ paramtypes.ParamSet = &Params{}
+
+const (
+	DefaultEVMDenom = types.AttoPhoton
+)
+
+// Parameter keys
+var (
+	ParamStoreKeyEVMDenom          = []byte("EVMDenom")
+	ParamStoreKeyEnableCreate      = []byte("EnableCreate")
+	ParamStoreKeyEnableCall        = []byte("EnableCall")
+	ParamStoreKeyExtraEIPs         = []byte("EnableExtraEIPs")
+	ParamStoreKeyChainConfig       = []byte("ChainConfig")
+	ParamStoreKeyEIP712AllowedMsgs = []byte("EIP712AllowedMsgs")
+
+	// AvailableExtraEIPs define the list of all EIPs that can be enabled by the
+	// EVM interpreter. These EIPs are applied in order and can override the
+	// instruction sets from the latest hard fork enabled by the ChainConfig. For
+	// more info check:
+	// https://github.com/ethereum/go-ethereum/blob/master/core/vm/interpreter.go#L97
+	AvailableExtraEIPs = []int64{1344, 1884, 2200, 2929, 3198, 3529}
+)
+
+// ParamKeyTable returns the parameter key table.
+func ParamKeyTable() paramtypes.KeyTable {
+	return paramtypes.NewKeyTable().RegisterParamSet(&Params{})
+}
+
+// NewParams creates a new Params instance
+func NewParams(evmDenom string, enableCreate, enableCall bool, config ChainConfig, extraEIPs ...int64) Params {
+	return Params{
+		EvmDenom:          evmDenom,
+		EnableCreate:      enableCreate,
+		EnableCall:        enableCall,
+		ExtraEIPs:         extraEIPs,
+		ChainConfig:       config,
+		EIP712AllowedMsgs: []EIP712AllowedMsg{},
+	}
+}
+
+// DefaultParams returns default evm parameters
+// ExtraEIPs is empty to prevent overriding the latest hard fork instruction set
+func DefaultParams() Params {
+	return Params{
+		EvmDenom:          DefaultEVMDenom,
+		EnableCreate:      true,
+		EnableCall:        true,
+		ChainConfig:       DefaultChainConfig(),
+		ExtraEIPs:         nil,
+		EIP712AllowedMsgs: []EIP712AllowedMsg{},
+	}
+}
+
+// ParamSetPairs returns the parameter set pairs.
+func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs {
+	return paramtypes.ParamSetPairs{
+		paramtypes.NewParamSetPair(ParamStoreKeyEVMDenom, &p.EvmDenom, validateEVMDenom),
+		paramtypes.NewParamSetPair(ParamStoreKeyEnableCreate, &p.EnableCreate, validateBool),
+		paramtypes.NewParamSetPair(ParamStoreKeyEnableCall, &p.EnableCall, validateBool),
+		paramtypes.NewParamSetPair(ParamStoreKeyExtraEIPs, &p.ExtraEIPs, validateEIPs),
+		paramtypes.NewParamSetPair(ParamStoreKeyChainConfig, &p.ChainConfig, validateChainConfig),
+		paramtypes.NewParamSetPair(ParamStoreKeyEIP712AllowedMsgs, &p.EIP712AllowedMsgs, validateEIP712AllowedMsgs),
+	}
+}
+
+// Validate performs basic validation on evm parameters.
+func (p Params) Validate() error {
+	if err := sdk.ValidateDenom(p.EvmDenom); err != nil {
+		return err
+	}
+
+	if err := validateEIPs(p.ExtraEIPs); err != nil {
+		return err
+	}
+
+	if err := p.ChainConfig.Validate(); err != nil {
+		return err
+	}
+
+	return validateEIP712AllowedMsgs(p.EIP712AllowedMsgs)
+}
+
+// EIP712AllowedMsgFromMsgType returns the EIP712AllowedMsg for a given message type url.
+func (p Params) EIP712AllowedMsgFromMsgType(msgTypeUrl string) *EIP712AllowedMsg {
+	for _, allowedMsg := range p.EIP712AllowedMsgs {
+		if allowedMsg.MsgTypeUrl == msgTypeUrl {
+			return &allowedMsg
+		}
+	}
+	return nil
+}
+
+// EIPs returns the ExtraEips as a int slice
+func (p Params) EIPs() []int {
+	eips := make([]int, len(p.ExtraEIPs))
+	for i, eip := range p.ExtraEIPs {
+		eips[i] = int(eip)
+	}
+	return eips
+}
+
+func validateEVMDenom(i interface{}) error {
+	denom, ok := i.(string)
+	if !ok {
+		return fmt.Errorf("invalid parameter EVM denom type: %T", i)
+	}
+
+	return sdk.ValidateDenom(denom)
+}
+
+func validateBool(i interface{}) error {
+	_, ok := i.(bool)
+	if !ok {
+		return fmt.Errorf("invalid parameter type: %T", i)
+	}
+	return nil
+}
+
+func validateEIPs(i interface{}) error {
+	eips, ok := i.([]int64)
+	if !ok {
+		return fmt.Errorf("invalid EIP slice type: %T", i)
+	}
+
+	for _, eip := range eips {
+		if !vm.ValidEip(int(eip)) {
+			return fmt.Errorf("EIP %d is not activateable, valid EIPS are: %s", eip, vm.ActivateableEips())
+		}
+	}
+
+	return nil
+}
+
+func validateChainConfig(i interface{}) error {
+	cfg, ok := i.(ChainConfig)
+	if !ok {
+		return fmt.Errorf("invalid chain config type: %T", i)
+	}
+
+	return cfg.Validate()
+}
+
+func validateEIP712AllowedMsgs(i interface{}) error {
+	allowedMsgs, ok := i.([]EIP712AllowedMsg)
+	if !ok {
+		return fmt.Errorf("invalid EIP712AllowedMsg slice type: %T", i)
+	}
+
+	// ensure no duplicate msg type urls
+	msgTypes := make(map[string]bool)
+	for _, allowedMsg := range allowedMsgs {
+		if _, ok := msgTypes[allowedMsg.MsgTypeUrl]; ok {
+			return fmt.Errorf("duplicate eip712 allowed legacy msg type: %s", allowedMsg.MsgTypeUrl)
+		}
+		msgTypes[allowedMsg.MsgTypeUrl] = true
+	}
+
+	return nil
+}
+
+// IsLondon returns if london hardfork is enabled.
+func IsLondon(ethConfig *params.ChainConfig, height int64) bool {
+	return ethConfig.IsLondon(big.NewInt(height))
+}
diff --git a/x/evm/module.go b/x/evm/module.go
index 1335b263..96de5d7d 100644
--- a/x/evm/module.go
+++ b/x/evm/module.go
@@ -30,6 +30,9 @@ var (
 	_ module.AppModuleBasic = AppModuleBasic{}
 )
 
+// ConsensusVersion defines the current module consensus version.
+const ConsensusVersion = 2
+
 // AppModuleBasic defines the basic application module used by the evm module.
 type AppModuleBasic struct{}
 
@@ -44,7 +47,7 @@ func (AppModuleBasic) RegisterLegacyAminoCodec(_ *codec.LegacyAmino) {
 
 // ConsensusVersion returns the consensus state-breaking version for the module.
 func (AppModuleBasic) ConsensusVersion() uint64 {
-	return 1
+	return ConsensusVersion
 }
 
 // DefaultGenesis returns default genesis state as raw bytes for the evm
@@ -123,7 +126,10 @@ func (am AppModule) RegisterServices(cfg module.Configurator) {
 	types.RegisterMsgServer(cfg.MsgServer(), am.keeper)
 	types.RegisterQueryServer(cfg.QueryServer(), am.keeper)
 
-	_ = keeper.NewMigrator(*am.keeper)
+	m := keeper.NewMigrator(*am.keeper)
+	if err := cfg.RegisterMigration(types.ModuleName, 1, m.Migrate1to2); err != nil {
+		panic(fmt.Sprintf("failed to migrate x/committee from version 1 to 2: %v", err))
+	}
 }
 
 // Route returns the message routing key for the evm module.
diff --git a/x/evm/types/evm.pb.go b/x/evm/types/evm.pb.go
index 78977f2b..f214beaf 100644
--- a/x/evm/types/evm.pb.go
+++ b/x/evm/types/evm.pb.go
@@ -37,6 +37,8 @@ type Params struct {
 	ExtraEIPs []int64 `protobuf:"varint,4,rep,packed,name=extra_eips,json=extraEips,proto3" json:"extra_eips,omitempty" yaml:"extra_eips"`
 	// chain config defines the EVM chain configuration parameters
 	ChainConfig ChainConfig `protobuf:"bytes,5,opt,name=chain_config,json=chainConfig,proto3" json:"chain_config" yaml:"chain_config"`
+	// list of allowed eip712 msgs and their types
+	EIP712AllowedMsgs []EIP712AllowedMsg `protobuf:"bytes,6,rep,name=eip712_allowed_msgs,json=eip712AllowedMsgs,proto3" json:"eip712_allowed_msgs"`
 }
 
 func (m *Params) Reset()         { *m = Params{} }
@@ -107,6 +109,13 @@ func (m *Params) GetChainConfig() ChainConfig {
 	return ChainConfig{}
 }
 
+func (m *Params) GetEIP712AllowedMsgs() []EIP712AllowedMsg {
+	if m != nil {
+		return m.EIP712AllowedMsgs
+	}
+	return nil
+}
+
 // ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
 // instead of *big.Int.
 type ChainConfig struct {
@@ -643,6 +652,187 @@ func (m *TraceConfig) GetEnableReturnData() bool {
 	return false
 }
 
+// EIP712AllowedMsg stores an allowed legacy msg and its eip712 type.
+type EIP712AllowedMsg struct {
+	// msg's proto type name. ie "/cosmos.bank.v1beta1.MsgSend"
+	MsgTypeUrl string `protobuf:"bytes,1,opt,name=msg_type_url,json=msgTypeUrl,proto3" json:"msg_type_url,omitempty"`
+	// name of the eip712 value type. ie "MsgValueSend"
+	MsgValueTypeName string `protobuf:"bytes,2,opt,name=msg_value_type_name,json=msgValueTypeName,proto3" json:"msg_value_type_name,omitempty"`
+	// types of the msg value
+	ValueTypes []EIP712MsgAttrType `protobuf:"bytes,3,rep,name=value_types,json=valueTypes,proto3" json:"value_types"`
+	// nested types of the msg value
+	NestedTypes []EIP712NestedMsgType `protobuf:"bytes,4,rep,name=nested_types,json=nestedTypes,proto3" json:"nested_types"`
+}
+
+func (m *EIP712AllowedMsg) Reset()         { *m = EIP712AllowedMsg{} }
+func (m *EIP712AllowedMsg) String() string { return proto.CompactTextString(m) }
+func (*EIP712AllowedMsg) ProtoMessage()    {}
+func (*EIP712AllowedMsg) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{8}
+}
+func (m *EIP712AllowedMsg) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *EIP712AllowedMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_EIP712AllowedMsg.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *EIP712AllowedMsg) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_EIP712AllowedMsg.Merge(m, src)
+}
+func (m *EIP712AllowedMsg) XXX_Size() int {
+	return m.Size()
+}
+func (m *EIP712AllowedMsg) XXX_DiscardUnknown() {
+	xxx_messageInfo_EIP712AllowedMsg.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_EIP712AllowedMsg proto.InternalMessageInfo
+
+func (m *EIP712AllowedMsg) GetMsgTypeUrl() string {
+	if m != nil {
+		return m.MsgTypeUrl
+	}
+	return ""
+}
+
+func (m *EIP712AllowedMsg) GetMsgValueTypeName() string {
+	if m != nil {
+		return m.MsgValueTypeName
+	}
+	return ""
+}
+
+func (m *EIP712AllowedMsg) GetValueTypes() []EIP712MsgAttrType {
+	if m != nil {
+		return m.ValueTypes
+	}
+	return nil
+}
+
+func (m *EIP712AllowedMsg) GetNestedTypes() []EIP712NestedMsgType {
+	if m != nil {
+		return m.NestedTypes
+	}
+	return nil
+}
+
+// EIP712MsgType is the eip712 type of a single message.
+type EIP712NestedMsgType struct {
+	// name of the nested type. ie "Fee", "Coin"
+	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	// attrs of the nested type
+	Attrs []EIP712MsgAttrType `protobuf:"bytes,2,rep,name=attrs,proto3" json:"attrs"`
+}
+
+func (m *EIP712NestedMsgType) Reset()         { *m = EIP712NestedMsgType{} }
+func (m *EIP712NestedMsgType) String() string { return proto.CompactTextString(m) }
+func (*EIP712NestedMsgType) ProtoMessage()    {}
+func (*EIP712NestedMsgType) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{9}
+}
+func (m *EIP712NestedMsgType) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *EIP712NestedMsgType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_EIP712NestedMsgType.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *EIP712NestedMsgType) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_EIP712NestedMsgType.Merge(m, src)
+}
+func (m *EIP712NestedMsgType) XXX_Size() int {
+	return m.Size()
+}
+func (m *EIP712NestedMsgType) XXX_DiscardUnknown() {
+	xxx_messageInfo_EIP712NestedMsgType.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_EIP712NestedMsgType proto.InternalMessageInfo
+
+func (m *EIP712NestedMsgType) GetName() string {
+	if m != nil {
+		return m.Name
+	}
+	return ""
+}
+
+func (m *EIP712NestedMsgType) GetAttrs() []EIP712MsgAttrType {
+	if m != nil {
+		return m.Attrs
+	}
+	return nil
+}
+
+// EIP712MsgAttrType is the eip712 type of a single message attribute.
+type EIP712MsgAttrType struct {
+	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
+}
+
+func (m *EIP712MsgAttrType) Reset()         { *m = EIP712MsgAttrType{} }
+func (m *EIP712MsgAttrType) String() string { return proto.CompactTextString(m) }
+func (*EIP712MsgAttrType) ProtoMessage()    {}
+func (*EIP712MsgAttrType) Descriptor() ([]byte, []int) {
+	return fileDescriptor_d21ecc92c8c8583e, []int{10}
+}
+func (m *EIP712MsgAttrType) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *EIP712MsgAttrType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_EIP712MsgAttrType.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *EIP712MsgAttrType) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_EIP712MsgAttrType.Merge(m, src)
+}
+func (m *EIP712MsgAttrType) XXX_Size() int {
+	return m.Size()
+}
+func (m *EIP712MsgAttrType) XXX_DiscardUnknown() {
+	xxx_messageInfo_EIP712MsgAttrType.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_EIP712MsgAttrType proto.InternalMessageInfo
+
+func (m *EIP712MsgAttrType) GetName() string {
+	if m != nil {
+		return m.Name
+	}
+	return ""
+}
+
+func (m *EIP712MsgAttrType) GetType() string {
+	if m != nil {
+		return m.Type
+	}
+	return ""
+}
+
 func init() {
 	proto.RegisterType((*Params)(nil), "ethermint.evm.v1.Params")
 	proto.RegisterType((*ChainConfig)(nil), "ethermint.evm.v1.ChainConfig")
@@ -652,105 +842,121 @@ func init() {
 	proto.RegisterType((*TxResult)(nil), "ethermint.evm.v1.TxResult")
 	proto.RegisterType((*AccessTuple)(nil), "ethermint.evm.v1.AccessTuple")
 	proto.RegisterType((*TraceConfig)(nil), "ethermint.evm.v1.TraceConfig")
+	proto.RegisterType((*EIP712AllowedMsg)(nil), "ethermint.evm.v1.EIP712AllowedMsg")
+	proto.RegisterType((*EIP712NestedMsgType)(nil), "ethermint.evm.v1.EIP712NestedMsgType")
+	proto.RegisterType((*EIP712MsgAttrType)(nil), "ethermint.evm.v1.EIP712MsgAttrType")
 }
 
 func init() { proto.RegisterFile("ethermint/evm/v1/evm.proto", fileDescriptor_d21ecc92c8c8583e) }
 
 var fileDescriptor_d21ecc92c8c8583e = []byte{
-	// 1475 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xdf, 0x6e, 0xdb, 0xb6,
-	0x1a, 0x4f, 0x62, 0x27, 0x91, 0x69, 0xc7, 0x56, 0x98, 0x34, 0xc7, 0x4d, 0x71, 0xa2, 0x1c, 0x5d,
-	0x1c, 0xe4, 0x00, 0x6d, 0xdc, 0xa4, 0x08, 0x4e, 0xd1, 0x62, 0x17, 0x51, 0x92, 0xb6, 0xc9, 0xba,
-	0x2d, 0x60, 0x32, 0x0c, 0x18, 0x30, 0x08, 0xb4, 0xc4, 0xca, 0x5a, 0x24, 0xd1, 0x20, 0x29, 0xd7,
-	0x1e, 0xf6, 0x00, 0x03, 0x76, 0xb3, 0x47, 0xd8, 0x2b, 0xec, 0x2d, 0x8a, 0x5d, 0xf5, 0x66, 0xc0,
-	0xb0, 0x0b, 0xa1, 0x48, 0xef, 0x72, 0xe9, 0x27, 0x18, 0x44, 0xd2, 0x7f, 0x13, 0x6c, 0x4b, 0xae,
-	0xcc, 0xdf, 0xf7, 0xe7, 0xf7, 0x23, 0x3f, 0x7e, 0x14, 0x69, 0xb0, 0x4e, 0x44, 0x8b, 0xb0, 0x38,
-	0x4c, 0x44, 0x83, 0x74, 0xe2, 0x46, 0x67, 0x27, 0xff, 0xd9, 0x6e, 0x33, 0x2a, 0x28, 0x34, 0x87,
-	0xbe, 0xed, 0xdc, 0xd8, 0xd9, 0x59, 0x5f, 0x0d, 0x68, 0x40, 0xa5, 0xb3, 0x91, 0x8f, 0x54, 0x9c,
-	0xfd, 0xdb, 0x1c, 0x58, 0x38, 0xc5, 0x0c, 0xc7, 0x1c, 0xee, 0x80, 0x12, 0xe9, 0xc4, 0xae, 0x4f,
-	0x12, 0x1a, 0xd7, 0x67, 0x37, 0x67, 0xb7, 0x4a, 0xce, 0x6a, 0x3f, 0xb3, 0xcc, 0x1e, 0x8e, 0xa3,
-	0x67, 0xf6, 0xd0, 0x65, 0x23, 0x83, 0x74, 0xe2, 0xc3, 0x7c, 0x08, 0x3f, 0x01, 0x4b, 0x24, 0xc1,
-	0xcd, 0x88, 0xb8, 0x1e, 0x23, 0x58, 0x90, 0xfa, 0xdc, 0xe6, 0xec, 0x96, 0xe1, 0xd4, 0xfb, 0x99,
-	0xb5, 0xaa, 0xd3, 0xc6, 0xdd, 0x36, 0xaa, 0x28, 0x7c, 0x20, 0x21, 0xfc, 0x3f, 0x28, 0x0f, 0xfc,
-	0x38, 0x8a, 0xea, 0x05, 0x99, 0xbc, 0xd6, 0xcf, 0x2c, 0x38, 0x99, 0x8c, 0xa3, 0xc8, 0x46, 0x40,
-	0xa7, 0xe2, 0x28, 0x82, 0xfb, 0x00, 0x90, 0xae, 0x60, 0xd8, 0x25, 0x61, 0x9b, 0xd7, 0x8b, 0x9b,
-	0x85, 0xad, 0x82, 0x63, 0x5f, 0x66, 0x56, 0xe9, 0x28, 0xb7, 0x1e, 0x1d, 0x9f, 0xf2, 0x7e, 0x66,
-	0x2d, 0x6b, 0x92, 0x61, 0xa0, 0x8d, 0x4a, 0x12, 0x1c, 0x85, 0x6d, 0x0e, 0xbf, 0x01, 0x15, 0xaf,
-	0x85, 0xc3, 0xc4, 0xf5, 0x68, 0xf2, 0x26, 0x0c, 0xea, 0xf3, 0x9b, 0xb3, 0x5b, 0xe5, 0xdd, 0x7f,
-	0x6f, 0x4f, 0xd7, 0x6d, 0xfb, 0x20, 0x8f, 0x3a, 0x90, 0x41, 0xce, 0x83, 0x77, 0x99, 0x35, 0xd3,
-	0xcf, 0xac, 0x15, 0x45, 0x3d, 0x4e, 0x60, 0xa3, 0xb2, 0x37, 0x8a, 0xb4, 0x7f, 0xa9, 0x82, 0xf2,
-	0x58, 0x26, 0x8c, 0x41, 0xad, 0x45, 0x63, 0xc2, 0x05, 0xc1, 0xbe, 0xdb, 0x8c, 0xa8, 0x77, 0xa1,
-	0x4b, 0x7c, 0xf8, 0x47, 0x66, 0xfd, 0x37, 0x08, 0x45, 0x2b, 0x6d, 0x6e, 0x7b, 0x34, 0x6e, 0x78,
-	0x94, 0xc7, 0x94, 0xeb, 0x9f, 0x47, 0xdc, 0xbf, 0x68, 0x88, 0x5e, 0x9b, 0xf0, 0xed, 0xe3, 0x44,
-	0xf4, 0x33, 0x6b, 0x4d, 0x09, 0x4f, 0x51, 0xd9, 0xa8, 0x3a, 0xb4, 0x38, 0xb9, 0x01, 0xf6, 0x40,
-	0xd5, 0xc7, 0xd4, 0x7d, 0x43, 0xd9, 0x85, 0x56, 0x9b, 0x93, 0x6a, 0x67, 0xff, 0x5c, 0xed, 0x32,
-	0xb3, 0x2a, 0x87, 0xfb, 0x5f, 0xbc, 0xa0, 0xec, 0x42, 0x72, 0xf6, 0x33, 0xeb, 0x9e, 0x52, 0x9f,
-	0x64, 0xb6, 0x51, 0xc5, 0xc7, 0x74, 0x18, 0x06, 0xbf, 0x02, 0xe6, 0x30, 0x80, 0xa7, 0xed, 0x36,
-	0x65, 0x42, 0xef, 0xec, 0xa3, 0xcb, 0xcc, 0xaa, 0x6a, 0xca, 0x33, 0xe5, 0xe9, 0x67, 0xd6, 0xbf,
-	0xa6, 0x48, 0x75, 0x8e, 0x8d, 0xaa, 0x9a, 0x56, 0x87, 0x42, 0x0e, 0x2a, 0x24, 0x6c, 0xef, 0xec,
-	0x3d, 0xd6, 0x2b, 0x2a, 0xca, 0x15, 0x9d, 0xde, 0x6a, 0x45, 0xe5, 0xa3, 0xe3, 0xd3, 0x9d, 0xbd,
-	0xc7, 0x83, 0x05, 0xe9, 0x7d, 0x1c, 0xa7, 0xb5, 0x51, 0x59, 0x41, 0xb5, 0x9a, 0x63, 0xa0, 0xa1,
-	0xdb, 0xc2, 0xbc, 0x25, 0xbb, 0xa4, 0xe4, 0x6c, 0x5d, 0x66, 0x16, 0x50, 0x4c, 0xaf, 0x30, 0x6f,
-	0x8d, 0xf6, 0xa5, 0xd9, 0xfb, 0x0e, 0x27, 0x22, 0x4c, 0xe3, 0x01, 0x17, 0x50, 0xc9, 0x79, 0xd4,
-	0x70, 0xfe, 0x7b, 0x7a, 0xfe, 0x0b, 0x77, 0x9e, 0xff, 0xde, 0x4d, 0xf3, 0xdf, 0x9b, 0x9c, 0xbf,
-	0x8a, 0x19, 0x8a, 0x3e, 0xd5, 0xa2, 0x8b, 0x77, 0x16, 0x7d, 0x7a, 0x93, 0xe8, 0xd3, 0x49, 0x51,
-	0x15, 0x93, 0x37, 0xfb, 0x54, 0x25, 0xea, 0xc6, 0xdd, 0x9b, 0xfd, 0x5a, 0x51, 0xab, 0x43, 0x8b,
-	0x92, 0xfb, 0x1e, 0xac, 0x7a, 0x34, 0xe1, 0x22, 0xb7, 0x25, 0xb4, 0x1d, 0x11, 0xad, 0x59, 0x92,
-	0x9a, 0xc7, 0xb7, 0xd2, 0x7c, 0xa0, 0x4f, 0xf6, 0x0d, 0x7c, 0x36, 0x5a, 0x99, 0x34, 0x2b, 0xf5,
-	0x36, 0x30, 0xdb, 0x44, 0x10, 0xc6, 0x9b, 0x29, 0x0b, 0xb4, 0x32, 0x90, 0xca, 0x47, 0xb7, 0x52,
-	0xd6, 0xe7, 0x60, 0x9a, 0xcb, 0x46, 0xb5, 0x91, 0x49, 0x29, 0x7e, 0x0b, 0xaa, 0x61, 0x3e, 0x8d,
-	0x66, 0x1a, 0x69, 0xbd, 0xb2, 0xd4, 0x3b, 0xb8, 0x95, 0x9e, 0x3e, 0xcc, 0x93, 0x4c, 0x36, 0x5a,
-	0x1a, 0x18, 0x94, 0x56, 0x0a, 0x60, 0x9c, 0x86, 0xcc, 0x0d, 0x22, 0xec, 0x85, 0x84, 0x69, 0xbd,
-	0x8a, 0xd4, 0x7b, 0x79, 0x2b, 0xbd, 0xfb, 0x4a, 0xef, 0x3a, 0x9b, 0x8d, 0xcc, 0xdc, 0xf8, 0x52,
-	0xd9, 0x94, 0xac, 0x0f, 0x2a, 0x4d, 0xc2, 0xa2, 0x30, 0xd1, 0x82, 0x4b, 0x52, 0x70, 0xff, 0x56,
-	0x82, 0xba, 0x4f, 0xc7, 0x79, 0x6c, 0x54, 0x56, 0x70, 0xa8, 0x12, 0xd1, 0xc4, 0xa7, 0x03, 0x95,
-	0xe5, 0xbb, 0xab, 0x8c, 0xf3, 0xd8, 0xa8, 0xac, 0xa0, 0x52, 0xe9, 0x82, 0x15, 0xcc, 0x18, 0x7d,
-	0x3b, 0x55, 0x43, 0x28, 0xc5, 0x5e, 0xdd, 0x4a, 0x6c, 0x5d, 0x89, 0xdd, 0x40, 0x67, 0xa3, 0x65,
-	0x69, 0x9d, 0xa8, 0x22, 0x05, 0x66, 0x4c, 0x58, 0x40, 0xc6, 0xef, 0x81, 0x95, 0xbb, 0xb7, 0xe6,
-	0x34, 0x97, 0x8d, 0xaa, 0xd2, 0x34, 0xfc, 0xf6, 0x9f, 0x14, 0x8d, 0xaa, 0x59, 0x3b, 0x29, 0x1a,
-	0x35, 0xd3, 0x3c, 0x29, 0x1a, 0xa6, 0xb9, 0x8c, 0x96, 0x7a, 0x34, 0xa2, 0x6e, 0xe7, 0x89, 0xca,
-	0x40, 0x65, 0xf2, 0x16, 0x73, 0x7d, 0x90, 0x51, 0xd5, 0xc3, 0x02, 0x47, 0x3d, 0x2e, 0x34, 0x5d,
-	0x03, 0xcc, 0x9f, 0x89, 0xfc, 0x5d, 0x60, 0x82, 0xc2, 0x05, 0xe9, 0xa9, 0x0b, 0x12, 0xe5, 0x43,
-	0xb8, 0x0a, 0xe6, 0x3b, 0x38, 0x4a, 0xd5, 0x03, 0xa3, 0x84, 0x14, 0xb0, 0x4f, 0x41, 0xed, 0x9c,
-	0xe1, 0x84, 0x63, 0x4f, 0x84, 0x34, 0x79, 0x4d, 0x03, 0x0e, 0x21, 0x28, 0xca, 0x0f, 0xb5, 0xca,
-	0x95, 0x63, 0xf8, 0x3f, 0x50, 0x8c, 0x68, 0xc0, 0xeb, 0x73, 0x9b, 0x85, 0xad, 0xf2, 0xee, 0xbd,
-	0xeb, 0x57, 0xfc, 0x6b, 0x1a, 0x20, 0x19, 0x62, 0xff, 0x3a, 0x07, 0x0a, 0xaf, 0x69, 0x00, 0xeb,
-	0x60, 0x11, 0xfb, 0x3e, 0x23, 0x9c, 0x6b, 0xa6, 0x01, 0x84, 0x6b, 0x60, 0x41, 0xd0, 0x76, 0xe8,
-	0x29, 0xba, 0x12, 0xd2, 0x28, 0x17, 0xf6, 0xb1, 0xc0, 0xf2, 0xaa, 0xab, 0x20, 0x39, 0x86, 0xbb,
-	0xa0, 0x22, 0x57, 0xe6, 0x26, 0x69, 0xdc, 0x24, 0x4c, 0xde, 0x58, 0x45, 0xa7, 0x76, 0x95, 0x59,
-	0x65, 0x69, 0xff, 0x5c, 0x9a, 0xd1, 0x38, 0x80, 0x0f, 0xc1, 0xa2, 0xe8, 0x8e, 0x5f, 0x36, 0x2b,
-	0x57, 0x99, 0x55, 0x13, 0xa3, 0x65, 0xe6, 0x77, 0x09, 0x5a, 0x10, 0x5d, 0x79, 0xa7, 0x34, 0x80,
-	0x21, 0xba, 0x6e, 0x98, 0xf8, 0xa4, 0x2b, 0xef, 0x93, 0xa2, 0xb3, 0x7a, 0x95, 0x59, 0xe6, 0x58,
-	0xf8, 0x71, 0xee, 0x43, 0x8b, 0xa2, 0x2b, 0x07, 0xf0, 0x21, 0x00, 0x6a, 0x4a, 0x52, 0x41, 0xdd,
-	0x06, 0x4b, 0x57, 0x99, 0x55, 0x92, 0x56, 0xc9, 0x3d, 0x1a, 0x42, 0x1b, 0xcc, 0x2b, 0x6e, 0x43,
-	0x72, 0x57, 0xae, 0x32, 0xcb, 0x88, 0x68, 0xa0, 0x38, 0x95, 0x2b, 0x2f, 0x15, 0x23, 0x31, 0xed,
-	0x10, 0x5f, 0x7e, 0x70, 0x0d, 0x34, 0x80, 0xf6, 0x8f, 0x73, 0xc0, 0x38, 0xef, 0x22, 0xc2, 0xd3,
-	0x48, 0xc0, 0x17, 0xc0, 0xf4, 0x68, 0x22, 0x18, 0xf6, 0x84, 0x3b, 0x51, 0x5a, 0xe7, 0xc1, 0xa8,
-	0xc3, 0xa6, 0x23, 0x6c, 0x54, 0x1b, 0x98, 0xf6, 0x75, 0xfd, 0x57, 0xc1, 0x7c, 0x33, 0xa2, 0x34,
-	0x96, 0x9d, 0x50, 0x41, 0x0a, 0x40, 0x24, 0xab, 0x26, 0x77, 0xb9, 0x20, 0x1f, 0x72, 0xff, 0xb9,
-	0xbe, 0xcb, 0x53, 0xad, 0xe2, 0xac, 0xe9, 0xc7, 0x5c, 0x55, 0x69, 0xeb, 0x7c, 0x3b, 0xaf, 0xad,
-	0x6c, 0x25, 0x13, 0x14, 0x18, 0x11, 0x72, 0xd3, 0x2a, 0x28, 0x1f, 0xc2, 0x75, 0x60, 0x30, 0xd2,
-	0x21, 0x4c, 0x10, 0x5f, 0x6e, 0x8e, 0x81, 0x86, 0x18, 0xde, 0x07, 0x46, 0x80, 0xb9, 0x9b, 0x72,
-	0xe2, 0xab, 0x9d, 0x40, 0x8b, 0x01, 0xe6, 0x5f, 0x72, 0xe2, 0x3f, 0x2b, 0xfe, 0xf0, 0xb3, 0x35,
-	0x63, 0x63, 0x50, 0xde, 0xf7, 0x3c, 0xc2, 0xf9, 0x79, 0xda, 0x8e, 0xc8, 0x5f, 0x74, 0xd8, 0x2e,
-	0xa8, 0x70, 0x41, 0x19, 0x0e, 0x88, 0x7b, 0x41, 0x7a, 0xba, 0xcf, 0x54, 0xd7, 0x68, 0xfb, 0xa7,
-	0xa4, 0xc7, 0xd1, 0x38, 0xd0, 0x12, 0x1f, 0x0a, 0xa0, 0x7c, 0xce, 0xb0, 0x47, 0xf4, 0xa3, 0x33,
-	0xef, 0xd5, 0x1c, 0x32, 0x2d, 0xa1, 0x51, 0xae, 0x2d, 0xc2, 0x98, 0xd0, 0x54, 0xe8, 0xf3, 0x34,
-	0x80, 0x79, 0x06, 0x23, 0xa4, 0x4b, 0x3c, 0x59, 0xc6, 0x22, 0xd2, 0x08, 0xee, 0x81, 0x25, 0x3f,
-	0xe4, 0xf2, 0x35, 0xce, 0x05, 0xf6, 0x2e, 0xd4, 0xf2, 0x1d, 0xf3, 0x2a, 0xb3, 0x2a, 0xda, 0x71,
-	0x96, 0xdb, 0xd1, 0x04, 0x82, 0xcf, 0x41, 0x6d, 0x94, 0x26, 0x67, 0x2b, 0x6b, 0x63, 0x38, 0xf0,
-	0x2a, 0xb3, 0xaa, 0xc3, 0x50, 0xe9, 0x41, 0x53, 0x38, 0xdf, 0x69, 0x9f, 0x34, 0xd3, 0x40, 0x36,
-	0x9f, 0x81, 0x14, 0xc8, 0xad, 0x51, 0x18, 0x87, 0x42, 0x36, 0xdb, 0x3c, 0x52, 0x00, 0x3e, 0x07,
-	0x25, 0xda, 0x21, 0x8c, 0x85, 0x3e, 0xe1, 0xf2, 0xf6, 0xfd, 0xbb, 0xa7, 0x3c, 0x1a, 0xc5, 0xe7,
-	0x8b, 0xd3, 0xff, 0x34, 0x62, 0x12, 0x53, 0xd6, 0x93, 0xd7, 0xa9, 0x5e, 0x9c, 0x72, 0x7c, 0x26,
-	0xed, 0x68, 0x02, 0x41, 0x07, 0x40, 0x9d, 0xc6, 0x88, 0x48, 0x59, 0xe2, 0xca, 0xf3, 0x5f, 0x91,
-	0xb9, 0xf2, 0x14, 0x2a, 0x2f, 0x92, 0xce, 0x43, 0x2c, 0x30, 0xba, 0x66, 0x39, 0x29, 0x1a, 0x45,
-	0x73, 0xfe, 0xa4, 0x68, 0x2c, 0x9a, 0xc6, 0x70, 0xfd, 0x7a, 0x16, 0x68, 0x65, 0x80, 0xc7, 0xe8,
-	0x1d, 0xe7, 0xdd, 0xe5, 0xc6, 0xec, 0xfb, 0xcb, 0x8d, 0xd9, 0x0f, 0x97, 0x1b, 0xb3, 0x3f, 0x7d,
-	0xdc, 0x98, 0x79, 0xff, 0x71, 0x63, 0xe6, 0xf7, 0x8f, 0x1b, 0x33, 0x5f, 0x6f, 0x8d, 0x7d, 0xce,
-	0x45, 0x0b, 0x33, 0x1e, 0xf2, 0xc6, 0xe8, 0x0f, 0x62, 0x57, 0xfe, 0x45, 0x94, 0x1f, 0xf5, 0xe6,
-	0x82, 0xfc, 0xeb, 0xf7, 0xe4, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x69, 0xef, 0x82, 0x39, 0x40,
-	0x0e, 0x00, 0x00,
+	// 1683 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0xdd, 0x4e, 0xe4, 0xc8,
+	0x15, 0x06, 0xda, 0x80, 0xbb, 0xda, 0x74, 0x9b, 0x6a, 0x76, 0xd2, 0x33, 0xa3, 0x60, 0xe2, 0x28,
+	0x11, 0x91, 0x76, 0x60, 0x61, 0x85, 0x66, 0xb4, 0xa3, 0x28, 0xc2, 0x0c, 0xbb, 0x0b, 0x99, 0x99,
+	0xa0, 0x82, 0x4d, 0xa4, 0x48, 0x91, 0x55, 0x6d, 0xd7, 0x1a, 0x2f, 0xb6, 0xab, 0x55, 0x55, 0xdd,
+	0xd3, 0x1d, 0xe5, 0x01, 0x22, 0xe5, 0x26, 0x8f, 0x90, 0x57, 0xc8, 0x3b, 0xe4, 0x62, 0x95, 0xab,
+	0xbd, 0x8c, 0x72, 0x61, 0xad, 0x98, 0x3b, 0x2e, 0x79, 0x81, 0x44, 0xf5, 0xd3, 0xbf, 0x30, 0xc9,
+	0x36, 0x57, 0x5d, 0xe7, 0xef, 0xfb, 0xea, 0x9c, 0x3a, 0xae, 0x63, 0x37, 0x78, 0x42, 0xc4, 0x25,
+	0x61, 0x79, 0x5a, 0x88, 0x5d, 0xd2, 0xcb, 0x77, 0x7b, 0x7b, 0xf2, 0x67, 0xa7, 0xc3, 0xa8, 0xa0,
+	0xd0, 0x1d, 0xd9, 0x76, 0xa4, 0xb2, 0xb7, 0xf7, 0x64, 0x23, 0xa1, 0x09, 0x55, 0xc6, 0x5d, 0xb9,
+	0xd2, 0x7e, 0xfe, 0x3f, 0x2a, 0x60, 0xe5, 0x0c, 0x33, 0x9c, 0x73, 0xb8, 0x07, 0xaa, 0xa4, 0x97,
+	0x87, 0x31, 0x29, 0x68, 0xde, 0x5a, 0xdc, 0x5a, 0xdc, 0xae, 0x06, 0x1b, 0xb7, 0xa5, 0xe7, 0x0e,
+	0x70, 0x9e, 0x7d, 0xe6, 0x8f, 0x4c, 0x3e, 0xb2, 0x49, 0x2f, 0x7f, 0x25, 0x97, 0xf0, 0x97, 0x60,
+	0x8d, 0x14, 0xb8, 0x9d, 0x91, 0x30, 0x62, 0x04, 0x0b, 0xd2, 0x5a, 0xda, 0x5a, 0xdc, 0xb6, 0x83,
+	0xd6, 0x6d, 0xe9, 0x6d, 0x98, 0xb0, 0x49, 0xb3, 0x8f, 0x1c, 0x2d, 0x1f, 0x29, 0x11, 0x3e, 0x07,
+	0xb5, 0xa1, 0x1d, 0x67, 0x59, 0xab, 0xa2, 0x82, 0x1f, 0xdd, 0x96, 0x1e, 0x9c, 0x0e, 0xc6, 0x59,
+	0xe6, 0x23, 0x60, 0x42, 0x71, 0x96, 0xc1, 0x43, 0x00, 0x48, 0x5f, 0x30, 0x1c, 0x92, 0xb4, 0xc3,
+	0x5b, 0xd6, 0x56, 0x65, 0xbb, 0x12, 0xf8, 0xd7, 0xa5, 0x57, 0x3d, 0x96, 0xda, 0xe3, 0x93, 0x33,
+	0x7e, 0x5b, 0x7a, 0xeb, 0x06, 0x64, 0xe4, 0xe8, 0xa3, 0xaa, 0x12, 0x8e, 0xd3, 0x0e, 0x87, 0x7f,
+	0x00, 0x4e, 0x74, 0x89, 0xd3, 0x22, 0x8c, 0x68, 0xf1, 0x75, 0x9a, 0xb4, 0x96, 0xb7, 0x16, 0xb7,
+	0x6b, 0xfb, 0x3f, 0xde, 0x99, 0xad, 0xdb, 0xce, 0x91, 0xf4, 0x3a, 0x52, 0x4e, 0xc1, 0xd3, 0x6f,
+	0x4b, 0x6f, 0xe1, 0xb6, 0xf4, 0x9a, 0x1a, 0x7a, 0x12, 0xc0, 0x47, 0xb5, 0x68, 0xec, 0x09, 0x73,
+	0xd0, 0x24, 0x69, 0xe7, 0xf9, 0xde, 0x7e, 0x88, 0xb3, 0x8c, 0xbe, 0x23, 0x71, 0x98, 0xf3, 0x84,
+	0xb7, 0x56, 0xb6, 0x2a, 0xdb, 0xb5, 0x7d, 0xff, 0x2e, 0xcb, 0xf1, 0xc9, 0xd9, 0xf3, 0xbd, 0xfd,
+	0x43, 0xed, 0xfb, 0x86, 0x27, 0xc1, 0x63, 0x49, 0x75, 0x5d, 0x7a, 0xeb, 0xb3, 0x16, 0x8e, 0xd6,
+	0x35, 0xf2, 0x84, 0xca, 0xff, 0x7b, 0x1d, 0xd4, 0x8e, 0xa6, 0xe8, 0x1b, 0x97, 0x34, 0x27, 0x5c,
+	0x10, 0x1c, 0x87, 0xed, 0x8c, 0x46, 0x57, 0xe6, 0x44, 0x5f, 0xfd, 0xbb, 0xf4, 0x7e, 0x9e, 0xa4,
+	0xe2, 0xb2, 0xdb, 0xde, 0x89, 0x68, 0xbe, 0x1b, 0x51, 0x9e, 0x53, 0x6e, 0x7e, 0x9e, 0xf1, 0xf8,
+	0x6a, 0x57, 0x0c, 0x3a, 0x84, 0xef, 0x9c, 0x14, 0xe2, 0xb6, 0xf4, 0x1e, 0xe9, 0x3c, 0x67, 0xa0,
+	0x7c, 0x54, 0x1f, 0x69, 0x02, 0xa9, 0x80, 0x03, 0x50, 0x8f, 0x31, 0x0d, 0xbf, 0xa6, 0xec, 0xca,
+	0xb0, 0x2d, 0x29, 0xb6, 0xf3, 0x1f, 0xce, 0x76, 0x5d, 0x7a, 0xce, 0xab, 0xc3, 0xdf, 0x7c, 0x4e,
+	0xd9, 0x95, 0xc2, 0xbc, 0x2d, 0xbd, 0x8f, 0x34, 0xfb, 0x34, 0xb2, 0x8f, 0x9c, 0x18, 0xd3, 0x91,
+	0x1b, 0xfc, 0x1d, 0x70, 0x47, 0x0e, 0xbc, 0xdb, 0xe9, 0x50, 0x26, 0x4c, 0x23, 0x3d, 0xbb, 0x2e,
+	0xbd, 0xba, 0x81, 0x3c, 0xd7, 0x96, 0xdb, 0xd2, 0xfb, 0xd1, 0x0c, 0xa8, 0x89, 0xf1, 0x51, 0xdd,
+	0xc0, 0x1a, 0x57, 0xc8, 0x81, 0x43, 0xd2, 0xce, 0xde, 0xc1, 0x27, 0x26, 0x23, 0x4b, 0x65, 0x74,
+	0x36, 0x57, 0x46, 0xb5, 0xe3, 0x93, 0xb3, 0xbd, 0x83, 0x4f, 0x86, 0x09, 0x99, 0xb6, 0x99, 0x84,
+	0xf5, 0x51, 0x4d, 0x8b, 0x3a, 0x9b, 0x13, 0x60, 0xc4, 0xf0, 0x12, 0xf3, 0x4b, 0xd5, 0x94, 0xd5,
+	0x60, 0xfb, 0xba, 0xf4, 0x80, 0x46, 0xfa, 0x12, 0xf3, 0xcb, 0xf1, 0xb9, 0xb4, 0x07, 0x7f, 0xc4,
+	0x85, 0x48, 0xbb, 0xf9, 0x10, 0x0b, 0xe8, 0x60, 0xe9, 0x35, 0xda, 0xff, 0x81, 0xd9, 0xff, 0xca,
+	0x83, 0xf7, 0x7f, 0x70, 0xdf, 0xfe, 0x0f, 0xa6, 0xf7, 0xaf, 0x7d, 0x46, 0xa4, 0x2f, 0x0c, 0xe9,
+	0xea, 0x83, 0x49, 0x5f, 0xdc, 0x47, 0xfa, 0x62, 0x9a, 0x54, 0xfb, 0xc8, 0x66, 0x9f, 0xa9, 0x44,
+	0xcb, 0x7e, 0x78, 0xb3, 0xdf, 0x29, 0x6a, 0x7d, 0xa4, 0xd1, 0x74, 0x7f, 0x02, 0x1b, 0x11, 0x2d,
+	0xb8, 0x90, 0xba, 0x82, 0x76, 0x32, 0x62, 0x38, 0xab, 0x8a, 0xf3, 0x64, 0x2e, 0xce, 0xa7, 0xe6,
+	0x22, 0xb9, 0x07, 0xcf, 0x47, 0xcd, 0x69, 0xb5, 0x66, 0xef, 0x00, 0xb7, 0x43, 0x04, 0x61, 0xbc,
+	0xdd, 0x65, 0x89, 0x61, 0x06, 0x8a, 0xf9, 0x78, 0x2e, 0x66, 0xf3, 0x1c, 0xcc, 0x62, 0xf9, 0xa8,
+	0x31, 0x56, 0x69, 0xc6, 0x6f, 0x40, 0x3d, 0x95, 0xdb, 0x68, 0x77, 0x33, 0xc3, 0x57, 0x53, 0x7c,
+	0x47, 0x73, 0xf1, 0x99, 0x87, 0x79, 0x1a, 0xc9, 0x47, 0x6b, 0x43, 0x85, 0xe6, 0xea, 0x02, 0x98,
+	0x77, 0x53, 0x16, 0x26, 0x19, 0x8e, 0x52, 0xc2, 0x0c, 0x9f, 0xa3, 0xf8, 0xbe, 0x98, 0x8b, 0xef,
+	0xb1, 0xe6, 0xbb, 0x8b, 0xe6, 0x23, 0x57, 0x2a, 0xbf, 0xd0, 0x3a, 0x4d, 0x1b, 0x03, 0xa7, 0x4d,
+	0x58, 0x96, 0x16, 0x86, 0x70, 0x4d, 0x11, 0x1e, 0xce, 0x45, 0x68, 0xfa, 0x74, 0x12, 0xc7, 0x47,
+	0x35, 0x2d, 0x8e, 0x58, 0x32, 0x5a, 0xc4, 0x74, 0xc8, 0xb2, 0xfe, 0x70, 0x96, 0x49, 0x1c, 0x1f,
+	0xd5, 0xb4, 0xa8, 0x59, 0xfa, 0xa0, 0x89, 0x19, 0xa3, 0xef, 0x66, 0x6a, 0x08, 0x15, 0xd9, 0x97,
+	0x73, 0x91, 0x3d, 0xd1, 0x64, 0xf7, 0xc0, 0xf9, 0x68, 0x5d, 0x69, 0xa7, 0xaa, 0x48, 0x81, 0x9b,
+	0x13, 0x96, 0x90, 0xc9, 0x39, 0xd0, 0x7c, 0x78, 0x6b, 0xce, 0x62, 0xf9, 0xa8, 0xae, 0x54, 0xa3,
+	0xbb, 0xff, 0xd4, 0xb2, 0xeb, 0x6e, 0xe3, 0xd4, 0xb2, 0x1b, 0xae, 0x7b, 0x6a, 0xd9, 0xae, 0xbb,
+	0x8e, 0xd6, 0x06, 0x34, 0xa3, 0x61, 0xef, 0x53, 0x1d, 0x81, 0x6a, 0xe4, 0x1d, 0xe6, 0xe6, 0x41,
+	0x46, 0xf5, 0x08, 0x0b, 0x9c, 0x0d, 0xb8, 0x30, 0x70, 0xbb, 0x60, 0xf9, 0x5c, 0xc8, 0xd7, 0x10,
+	0x17, 0x54, 0xae, 0xc8, 0x40, 0x0f, 0x48, 0x24, 0x97, 0x70, 0x03, 0x2c, 0xf7, 0x70, 0xd6, 0xd5,
+	0xef, 0x33, 0x55, 0xa4, 0x05, 0xff, 0x0c, 0x34, 0x2e, 0x18, 0x2e, 0x38, 0x8e, 0x44, 0x4a, 0x8b,
+	0xd7, 0x34, 0xe1, 0x10, 0x02, 0x4b, 0x5d, 0xd4, 0x3a, 0x56, 0xad, 0xe1, 0x2f, 0x80, 0x95, 0xd1,
+	0x84, 0xb7, 0x96, 0xd4, 0xac, 0xff, 0xe8, 0xee, 0xac, 0x7f, 0x4d, 0x13, 0xa4, 0x5c, 0xfc, 0x7f,
+	0x2e, 0x81, 0xca, 0x6b, 0x9a, 0xc0, 0x16, 0x58, 0xc5, 0x71, 0xcc, 0x08, 0xe7, 0x06, 0x69, 0x28,
+	0xc2, 0x47, 0x60, 0x45, 0xd0, 0x4e, 0x1a, 0x69, 0xb8, 0x2a, 0x32, 0x92, 0x24, 0x8e, 0xb1, 0xc0,
+	0x6a, 0xd4, 0x39, 0x48, 0xad, 0xe1, 0x3e, 0x70, 0x54, 0x66, 0x61, 0xd1, 0xcd, 0xdb, 0x84, 0xa9,
+	0x89, 0x65, 0x05, 0x8d, 0x9b, 0xd2, 0xab, 0x29, 0xfd, 0x5b, 0xa5, 0x46, 0x93, 0x02, 0xfc, 0x18,
+	0xac, 0x8a, 0xfe, 0xe4, 0xb0, 0x69, 0xde, 0x94, 0x5e, 0x43, 0x8c, 0xd3, 0x94, 0xb3, 0x04, 0xad,
+	0x88, 0xbe, 0x9a, 0x29, 0xbb, 0xc0, 0x16, 0xfd, 0x30, 0x2d, 0x62, 0xd2, 0x57, 0xf3, 0xc4, 0x0a,
+	0x36, 0x6e, 0x4a, 0xcf, 0x9d, 0x70, 0x3f, 0x91, 0x36, 0xb4, 0x2a, 0xfa, 0x6a, 0x01, 0x3f, 0x06,
+	0x40, 0x6f, 0x49, 0x31, 0xe8, 0x69, 0xb0, 0x76, 0x53, 0x7a, 0x55, 0xa5, 0x55, 0xd8, 0xe3, 0x25,
+	0xf4, 0xc1, 0xb2, 0xc6, 0xb6, 0x15, 0xb6, 0x73, 0x53, 0x7a, 0x76, 0x46, 0x13, 0x8d, 0xa9, 0x4d,
+	0xb2, 0x54, 0x8c, 0xe4, 0xb4, 0x47, 0x62, 0x75, 0xe1, 0xda, 0x68, 0x28, 0xfa, 0x7f, 0x59, 0x02,
+	0xf6, 0x45, 0x1f, 0x11, 0xde, 0xcd, 0x04, 0xfc, 0x1c, 0xb8, 0x11, 0x2d, 0x04, 0xc3, 0x91, 0x08,
+	0xa7, 0x4a, 0x1b, 0x3c, 0x1d, 0x77, 0xd8, 0xac, 0x87, 0x8f, 0x1a, 0x43, 0xd5, 0xa1, 0xa9, 0xff,
+	0x06, 0x58, 0x6e, 0x67, 0x94, 0xe6, 0xaa, 0x13, 0x1c, 0xa4, 0x05, 0x88, 0x54, 0xd5, 0xd4, 0x29,
+	0x57, 0xd4, 0x7b, 0xe3, 0x4f, 0xee, 0x9e, 0xf2, 0x4c, 0xab, 0x04, 0x8f, 0xcc, 0xbb, 0x63, 0x5d,
+	0x73, 0x9b, 0x78, 0x5f, 0xd6, 0x56, 0xb5, 0x92, 0x0b, 0x2a, 0x8c, 0x08, 0x75, 0x68, 0x0e, 0x92,
+	0x4b, 0xf8, 0x04, 0xd8, 0x8c, 0xf4, 0x08, 0x13, 0x24, 0x56, 0x87, 0x63, 0xa3, 0x91, 0x0c, 0x1f,
+	0x03, 0x3b, 0xc1, 0x3c, 0xec, 0x72, 0x12, 0xeb, 0x93, 0x40, 0xab, 0x09, 0xe6, 0x5f, 0x71, 0x12,
+	0x7f, 0x66, 0xfd, 0xf9, 0x6f, 0xde, 0x82, 0x8f, 0x41, 0xed, 0x30, 0x8a, 0x08, 0xe7, 0x17, 0xdd,
+	0x4e, 0x46, 0xfe, 0x47, 0x87, 0xed, 0x03, 0x87, 0x0b, 0xca, 0x70, 0x42, 0xc2, 0x2b, 0x32, 0x30,
+	0x7d, 0xa6, 0xbb, 0xc6, 0xe8, 0x7f, 0x4d, 0x06, 0x1c, 0x4d, 0x0a, 0x86, 0xe2, 0xfb, 0x0a, 0xa8,
+	0x5d, 0x30, 0x1c, 0x11, 0xf3, 0xd2, 0x29, 0x7b, 0x55, 0x8a, 0xcc, 0x50, 0x18, 0x49, 0x72, 0x8b,
+	0x34, 0x27, 0xb4, 0x2b, 0xcc, 0xf3, 0x34, 0x14, 0x65, 0x04, 0x23, 0xa4, 0x4f, 0x22, 0x55, 0x46,
+	0x0b, 0x19, 0x09, 0x1e, 0x80, 0xb5, 0x38, 0xe5, 0xea, 0xe5, 0x9f, 0x0b, 0x1c, 0x5d, 0xe9, 0xf4,
+	0x03, 0xf7, 0xa6, 0xf4, 0x1c, 0x63, 0x38, 0x97, 0x7a, 0x34, 0x25, 0xc1, 0x97, 0xa0, 0x31, 0x0e,
+	0x53, 0xbb, 0x55, 0xb5, 0xb1, 0x03, 0x78, 0x53, 0x7a, 0xf5, 0x91, 0xab, 0xb2, 0xa0, 0x19, 0x59,
+	0x9e, 0x74, 0x4c, 0xda, 0xdd, 0x44, 0x35, 0x9f, 0x8d, 0xb4, 0x20, 0xb5, 0x59, 0x9a, 0xa7, 0x42,
+	0x35, 0xdb, 0x32, 0xd2, 0x02, 0x7c, 0x09, 0xaa, 0xb4, 0x47, 0x18, 0x4b, 0x63, 0xc2, 0xd5, 0xf4,
+	0xfd, 0x7f, 0x5f, 0x0e, 0x68, 0xec, 0x2f, 0x93, 0x33, 0x1f, 0x36, 0x39, 0xc9, 0x29, 0x1b, 0xa8,
+	0x71, 0x6a, 0x92, 0xd3, 0x86, 0x37, 0x4a, 0x8f, 0xa6, 0x24, 0x18, 0x00, 0x68, 0xc2, 0x18, 0x11,
+	0x5d, 0x56, 0x84, 0xea, 0xf9, 0x77, 0x54, 0xac, 0x7a, 0x0a, 0xb5, 0x15, 0x29, 0xe3, 0x2b, 0x2c,
+	0x30, 0xba, 0xa3, 0x39, 0xb5, 0x6c, 0xcb, 0x5d, 0x3e, 0xb5, 0xec, 0x55, 0xd7, 0x1e, 0xe5, 0x6f,
+	0x76, 0x81, 0x9a, 0x43, 0x79, 0x02, 0xde, 0xff, 0xcf, 0x22, 0x70, 0x67, 0x3f, 0x40, 0xe0, 0x16,
+	0x70, 0x72, 0x9e, 0x84, 0xf2, 0xca, 0x0e, 0xbb, 0x2c, 0x33, 0xa7, 0x0d, 0x72, 0x9e, 0x5c, 0x0c,
+	0x3a, 0xe4, 0x2b, 0x96, 0xc1, 0x67, 0xa0, 0x29, 0x3d, 0xd4, 0xb5, 0xa9, 0xfd, 0x0a, 0x9c, 0x0f,
+	0x6f, 0x53, 0x37, 0xe7, 0xc9, 0x6f, 0xa5, 0x45, 0x7a, 0xbf, 0xc5, 0x39, 0x81, 0xa7, 0xa0, 0x36,
+	0x76, 0x95, 0x8f, 0x94, 0xbc, 0x38, 0x7f, 0xfa, 0xa1, 0x8f, 0xa4, 0x37, 0x3c, 0x39, 0x14, 0x82,
+	0xc9, 0xe8, 0xc0, 0x92, 0x0f, 0x15, 0x02, 0xbd, 0x21, 0x1c, 0x87, 0x6f, 0x81, 0x53, 0xc8, 0x4f,
+	0x93, 0xd8, 0x80, 0x59, 0x0a, 0xec, 0x67, 0x1f, 0x02, 0x7b, 0xab, 0x7c, 0xdf, 0xe8, 0xad, 0x1b,
+	0xb8, 0x9a, 0x06, 0x50, 0x78, 0xfe, 0x37, 0xa0, 0x79, 0x8f, 0xa7, 0xbc, 0x7f, 0x55, 0x4a, 0xe6,
+	0xe2, 0x97, 0x6b, 0xf8, 0x2b, 0xb0, 0x8c, 0x85, 0x60, 0xc3, 0x9b, 0x7f, 0x8e, 0x04, 0x74, 0x9c,
+	0xff, 0x12, 0xac, 0xdf, 0xf1, 0xb8, 0x97, 0x09, 0x02, 0x4b, 0x66, 0x67, 0x0a, 0xaa, 0xd6, 0x41,
+	0xf0, 0xed, 0xf5, 0xe6, 0xe2, 0x77, 0xd7, 0x9b, 0x8b, 0xdf, 0x5f, 0x6f, 0x2e, 0xfe, 0xf5, 0xfd,
+	0xe6, 0xc2, 0x77, 0xef, 0x37, 0x17, 0xfe, 0xf5, 0x7e, 0x73, 0xe1, 0xf7, 0xdb, 0x13, 0x93, 0x57,
+	0x5c, 0x62, 0xc6, 0x53, 0xbe, 0x3b, 0xfe, 0xeb, 0xa0, 0xaf, 0xfe, 0x3c, 0x50, 0xc5, 0x6a, 0xaf,
+	0xa8, 0x3f, 0x05, 0x3e, 0xfd, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe8, 0xff, 0x38, 0xa9, 0x5a,
+	0x10, 0x00, 0x00,
 }
 
 func (m *Params) Marshal() (dAtA []byte, err error) {
@@ -773,6 +979,20 @@ func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	_ = i
 	var l int
 	_ = l
+	if len(m.EIP712AllowedMsgs) > 0 {
+		for iNdEx := len(m.EIP712AllowedMsgs) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.EIP712AllowedMsgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintEvm(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x32
+		}
+	}
 	{
 		size, err := m.ChainConfig.MarshalToSizedBuffer(dAtA[:i])
 		if err != nil {
@@ -1429,6 +1649,152 @@ func (m *TraceConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	return len(dAtA) - i, nil
 }
 
+func (m *EIP712AllowedMsg) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *EIP712AllowedMsg) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *EIP712AllowedMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.NestedTypes) > 0 {
+		for iNdEx := len(m.NestedTypes) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.NestedTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintEvm(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x22
+		}
+	}
+	if len(m.ValueTypes) > 0 {
+		for iNdEx := len(m.ValueTypes) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.ValueTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintEvm(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x1a
+		}
+	}
+	if len(m.MsgValueTypeName) > 0 {
+		i -= len(m.MsgValueTypeName)
+		copy(dAtA[i:], m.MsgValueTypeName)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.MsgValueTypeName)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.MsgTypeUrl) > 0 {
+		i -= len(m.MsgTypeUrl)
+		copy(dAtA[i:], m.MsgTypeUrl)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.MsgTypeUrl)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *EIP712NestedMsgType) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *EIP712NestedMsgType) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *EIP712NestedMsgType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.Attrs) > 0 {
+		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Attrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintEvm(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Name)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *EIP712MsgAttrType) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *EIP712MsgAttrType) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *EIP712MsgAttrType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if len(m.Type) > 0 {
+		i -= len(m.Type)
+		copy(dAtA[i:], m.Type)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Type)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintEvm(dAtA, i, uint64(len(m.Name)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
 func encodeVarintEvm(dAtA []byte, offset int, v uint64) int {
 	offset -= sovEvm(v)
 	base := offset
@@ -1465,6 +1831,12 @@ func (m *Params) Size() (n int) {
 	}
 	l = m.ChainConfig.Size()
 	n += 1 + l + sovEvm(uint64(l))
+	if len(m.EIP712AllowedMsgs) > 0 {
+		for _, e := range m.EIP712AllowedMsgs {
+			l = e.Size()
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
 	return n
 }
 
@@ -1709,15 +2081,80 @@ func (m *TraceConfig) Size() (n int) {
 	return n
 }
 
-func sovEvm(x uint64) (n int) {
-	return (math_bits.Len64(x|1) + 6) / 7
-}
-func sozEvm(x uint64) (n int) {
-	return sovEvm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+func (m *EIP712AllowedMsg) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.MsgTypeUrl)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	l = len(m.MsgValueTypeName)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if len(m.ValueTypes) > 0 {
+		for _, e := range m.ValueTypes {
+			l = e.Size()
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
+	if len(m.NestedTypes) > 0 {
+		for _, e := range m.NestedTypes {
+			l = e.Size()
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
+	return n
 }
-func (m *Params) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
+
+func (m *EIP712NestedMsgType) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	if len(m.Attrs) > 0 {
+		for _, e := range m.Attrs {
+			l = e.Size()
+			n += 1 + l + sovEvm(uint64(l))
+		}
+	}
+	return n
+}
+
+func (m *EIP712MsgAttrType) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	l = len(m.Type)
+	if l > 0 {
+		n += 1 + l + sovEvm(uint64(l))
+	}
+	return n
+}
+
+func sovEvm(x uint64) (n int) {
+	return (math_bits.Len64(x|1) + 6) / 7
+}
+func sozEvm(x uint64) (n int) {
+	return sovEvm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *Params) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
 	for iNdEx < l {
 		preIndex := iNdEx
 		var wire uint64
@@ -1925,6 +2362,40 @@ func (m *Params) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EIP712AllowedMsgs", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.EIP712AllowedMsgs = append(m.EIP712AllowedMsgs, EIP712AllowedMsg{})
+			if err := m.EIP712AllowedMsgs[len(m.EIP712AllowedMsgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipEvm(dAtA[iNdEx:])
@@ -3695,6 +4166,418 @@ func (m *TraceConfig) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
+func (m *EIP712AllowedMsg) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: EIP712AllowedMsg: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: EIP712AllowedMsg: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MsgTypeUrl", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.MsgTypeUrl = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MsgValueTypeName", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.MsgValueTypeName = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ValueTypes", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ValueTypes = append(m.ValueTypes, EIP712MsgAttrType{})
+			if err := m.ValueTypes[len(m.ValueTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field NestedTypes", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.NestedTypes = append(m.NestedTypes, EIP712NestedMsgType{})
+			if err := m.NestedTypes[len(m.NestedTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *EIP712NestedMsgType) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: EIP712NestedMsgType: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: EIP712NestedMsgType: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Attrs = append(m.Attrs, EIP712MsgAttrType{})
+			if err := m.Attrs[len(m.Attrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *EIP712MsgAttrType) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowEvm
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: EIP712MsgAttrType: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: EIP712MsgAttrType: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowEvm
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthEvm
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Type = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipEvm(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthEvm
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
 func skipEvm(dAtA []byte) (n int, err error) {
 	l := len(dAtA)
 	iNdEx := 0
diff --git a/x/evm/types/params.go b/x/evm/types/params.go
index dc4caa20..03bc8a17 100644
--- a/x/evm/types/params.go
+++ b/x/evm/types/params.go
@@ -20,11 +20,12 @@ const (
 
 // Parameter keys
 var (
-	ParamStoreKeyEVMDenom     = []byte("EVMDenom")
-	ParamStoreKeyEnableCreate = []byte("EnableCreate")
-	ParamStoreKeyEnableCall   = []byte("EnableCall")
-	ParamStoreKeyExtraEIPs    = []byte("EnableExtraEIPs")
-	ParamStoreKeyChainConfig  = []byte("ChainConfig")
+	ParamStoreKeyEVMDenom          = []byte("EVMDenom")
+	ParamStoreKeyEnableCreate      = []byte("EnableCreate")
+	ParamStoreKeyEnableCall        = []byte("EnableCall")
+	ParamStoreKeyExtraEIPs         = []byte("EnableExtraEIPs")
+	ParamStoreKeyChainConfig       = []byte("ChainConfig")
+	ParamStoreKeyEIP712AllowedMsgs = []byte("EIP712AllowedMsgs")
 
 	// AvailableExtraEIPs define the list of all EIPs that can be enabled by the
 	// EVM interpreter. These EIPs are applied in order and can override the
@@ -42,11 +43,12 @@ func ParamKeyTable() paramtypes.KeyTable {
 // NewParams creates a new Params instance
 func NewParams(evmDenom string, enableCreate, enableCall bool, config ChainConfig, extraEIPs ...int64) Params {
 	return Params{
-		EvmDenom:     evmDenom,
-		EnableCreate: enableCreate,
-		EnableCall:   enableCall,
-		ExtraEIPs:    extraEIPs,
-		ChainConfig:  config,
+		EvmDenom:          evmDenom,
+		EnableCreate:      enableCreate,
+		EnableCall:        enableCall,
+		ExtraEIPs:         extraEIPs,
+		ChainConfig:       config,
+		EIP712AllowedMsgs: []EIP712AllowedMsg{},
 	}
 }
 
@@ -54,11 +56,12 @@ func NewParams(evmDenom string, enableCreate, enableCall bool, config ChainConfi
 // ExtraEIPs is empty to prevent overriding the latest hard fork instruction set
 func DefaultParams() Params {
 	return Params{
-		EvmDenom:     DefaultEVMDenom,
-		EnableCreate: true,
-		EnableCall:   true,
-		ChainConfig:  DefaultChainConfig(),
-		ExtraEIPs:    nil,
+		EvmDenom:          DefaultEVMDenom,
+		EnableCreate:      true,
+		EnableCall:        true,
+		ChainConfig:       DefaultChainConfig(),
+		ExtraEIPs:         nil,
+		EIP712AllowedMsgs: []EIP712AllowedMsg{},
 	}
 }
 
@@ -70,6 +73,7 @@ func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs {
 		paramtypes.NewParamSetPair(ParamStoreKeyEnableCall, &p.EnableCall, validateBool),
 		paramtypes.NewParamSetPair(ParamStoreKeyExtraEIPs, &p.ExtraEIPs, validateEIPs),
 		paramtypes.NewParamSetPair(ParamStoreKeyChainConfig, &p.ChainConfig, validateChainConfig),
+		paramtypes.NewParamSetPair(ParamStoreKeyEIP712AllowedMsgs, &p.EIP712AllowedMsgs, validateEIP712AllowedMsgs),
 	}
 }
 
@@ -83,7 +87,21 @@ func (p Params) Validate() error {
 		return err
 	}
 
-	return p.ChainConfig.Validate()
+	if err := p.ChainConfig.Validate(); err != nil {
+		return err
+	}
+
+	return validateEIP712AllowedMsgs(p.EIP712AllowedMsgs)
+}
+
+// EIP712AllowedMsgFromMsgType returns the EIP712AllowedMsg for a given message type url.
+func (p Params) EIP712AllowedMsgFromMsgType(msgTypeUrl string) *EIP712AllowedMsg {
+	for _, allowedMsg := range p.EIP712AllowedMsgs {
+		if allowedMsg.MsgTypeUrl == msgTypeUrl {
+			return &allowedMsg
+		}
+	}
+	return nil
 }
 
 // EIPs returns the ExtraEips as a int slice
@@ -136,6 +154,24 @@ func validateChainConfig(i interface{}) error {
 	return cfg.Validate()
 }
 
+func validateEIP712AllowedMsgs(i interface{}) error {
+	allowedMsgs, ok := i.([]EIP712AllowedMsg)
+	if !ok {
+		return fmt.Errorf("invalid EIP712AllowedMsg slice type: %T", i)
+	}
+
+	// ensure no duplicate msg type urls
+	msgTypes := make(map[string]bool)
+	for _, allowedMsg := range allowedMsgs {
+		if _, ok := msgTypes[allowedMsg.MsgTypeUrl]; ok {
+			return fmt.Errorf("duplicate eip712 allowed legacy msg type: %s", allowedMsg.MsgTypeUrl)
+		}
+		msgTypes[allowedMsg.MsgTypeUrl] = true
+	}
+
+	return nil
+}
+
 // IsLondon returns if london hardfork is enabled.
 func IsLondon(ethConfig *params.ChainConfig, height int64) bool {
 	return ethConfig.IsLondon(big.NewInt(height))
diff --git a/x/evm/types/params_test.go b/x/evm/types/params_test.go
index aa09fd5a..eeebf498 100644
--- a/x/evm/types/params_test.go
+++ b/x/evm/types/params_test.go
@@ -47,8 +47,25 @@ func TestParamsValidate(t *testing.T) {
 		},
 		{
 			"invalid chain config",
-			NewParams("ara", true, true, ChainConfig{}, 2929, 1884, 1344),
-			false,
+			NewParams("ara", true, true, ChainConfig{
+				HomesteadBlock: newIntPtr(-1),
+			}, 2929, 1884, 1344),
+			true,
+		},
+		{
+			"invalid eip712 allowed msgs",
+			Params{
+				EvmDenom:     "ara",
+				EnableCreate: true,
+				EnableCall:   true,
+				ChainConfig:  DefaultChainConfig(),
+				ExtraEIPs:    []int64{2929, 1884, 1344},
+				EIP712AllowedMsgs: []EIP712AllowedMsg{
+					{MsgTypeUrl: "/cosmos.bank.v1beta1.MsgSend", MsgValueTypeName: "MsgValueSend"},
+					{MsgTypeUrl: "/cosmos.bank.v1beta1.MsgSend", MsgValueTypeName: "MsgValueSend"},
+				},
+			},
+			true,
 		},
 	}
 
-- 
2.38.1

